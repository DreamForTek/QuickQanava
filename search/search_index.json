{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"QuickQanava","text":"<p>  (Linux, g++, Qt5.15, qmake)</p> <p> (Windows, msvc2019, Qt5.15, qmake)</p> <p> (Windows, msvc2019, Qt6.4, CMake)</p> <p> </p> <p>QuickQanava is licensed under BSD-3, specific features or support is available on demand: benoit@destrat.io</p> <p>Open an issue with <code>question</code> tag for support request / questions</p>"},{"location":"index.html#introduction","title":"Introduction","text":"<p><code>QuickQanava</code> is a C++17 library developed for rendering graphs and relational content within a Qt/QML application. It offers QML components and C++ classes designed for visualizing medium-sized directed graphs in a C++/QML application. QuickQanava emphasizes the presentation of relational content in a dynamic user interface, featuring Drag-and-Drop support, resizable content, and visual creation of topology. <code>QuickQanava</code> focus authoring of topology delegates in pure QML.</p> <p>QuickQanava main repository is hosted on GitHub: https://github.com/cneben/quickqanava</p> <p>QuickQanava is primarily developed with Qt 6.6.1 with MSVC2019 and g++11 (minimal required Qt version is Qt 6.5.0, recommended is Qt 6.6.1). </p> <p>If you are interested in Qt5.15 support, last release supporting Qt5 is 2.4.0</p> <ul> <li>Project homepage: http://cneben.github.io/QuickQanava/index.html</li> </ul> <p>Please refer to Installation manual and Graph, Nodes and Graph sections for more information about installing and using QuickQanava.</p>"},{"location":"index.html#gallery","title":"Gallery","text":"<p>QuickQanava samples</p> Node Grouping Visual Connection of Nodes <p></p>"},{"location":"advanced.html","title":"Advanced Use (C++)","text":""},{"location":"advanced.html#using-from-c","title":"Using from C++","text":"<p>QuickQanava rely on and underlying QML engine to efficiently draw visual content using QML scene graph (eventually with HW OpenGL acceleration). While the API is almost 100% usable from C++, a QML engine must be initialized in the background for rendering topology, a minimal QuickQanava initialization from QML should thus create graph view and a graph topology components:</p> <pre><code>// main.qml\nimport QuickQanava          2.0 as Qan\nimport \"qrc:/QuickQanava\"   as Qan\n\nApplicationWindow {\n    title: \"QuickQanava cpp API\"\n    Qan.GraphView {\n        anchors.fill: parent\n        graph : Qan.Graph {\n            objectName: \"graph\"\n            anchors.fill: parent\n        } // Qan.Graph: graph\n    }\n}\n</code></pre> <p>On the C++ side, a QML engine should be initialized before starting the application event loop:</p> <pre><code>// main.cpp\nint main(int argc, char** argv)\n{\n    QGuiApplication app(argc, argv);\n    QQmlApplicationEngine engine;\n    QuickQanava::initialize(&amp;engine);   // Mandatory\n    engine.load(QUrl(\"qrc:/main.qml\"));\n    // Custom \"synchronous\" topology initialization should be added here    \n    return app.exec();\n}\n</code></pre> <p>It is then easy to access <code>Qan.Graph{ objectName:\"graph\"}</code> QML component trough it's <code>qan::Graph</code>  virtual interface: <pre><code>  QPointer&lt;CustomGraph&gt; graph = nullptr;\n  for (const auto rootObject : engine.rootObjects()) {\n    graph = qobject_cast&lt;CustomGraph*&gt;(rootObject-&gt;findChild&lt;QQuickItem *&gt;(\"graph\"));\n    if (graph)\n      break;\n  }\n  if (graph) {\n    // Go on\n  }\n</code></pre></p> <p>At this point, any modification should be done:</p> <ul> <li>Synchronously before application event loop is started using app.exec().</li> <li>In signals handlers reacting to <code>qan::Graph</code> or <code>qan::GraphView</code> events such as <code>nodeClicked()</code> or <code>groupClicked()</code> and so on (See qan::Graph and qan::GraphView signals).</li> <li>Using behavior observers (See Behaviors section).</li> </ul> <p>Please refer to the cpp sample and more specifically cpp_sample.cpp for a sample about using <code>qan::Graph</code> topology related methods.</p>"},{"location":"advanced.html#defining-custom-topology","title":"Defining Custom Topology","text":"<p>QuickQanava topology is described using GTpo library. Topology is modelled using non visual objects modelling node (qan::Node connected by directed edges (qan::Edge eventually grouped in qan::Group. These non-visual objects (called primitives) are mapped to QML QQuickItem based visual items. Concrete QQuickItem are generated on demand using QML QQmlComponent objects. </p> <p>QuickQanava provide default delegates for all primitives, but custom delegate could be specify by providing an argument for all primitive creation functions: <code>qan::Graph::insertNode()</code>, <code>qan::Graph::insertEdge()</code>, <code>qan::Graph::insertGroup()</code> and their QML counterpart in <code>Qan.Graph</code>. Simple custom delegate mapping is described in custom nodes and custom groups sections.</p> <p>Primitives classes could be subclassed from c++ to provide specific customization. Mapping between non-visual topology primitive and their QtQuick counterpart is managed trought static singleton factories defined in <code>qan::Node</code>, <code>qan::Edge</code> and <code>qan::Group</code>. Theses factories are automatically called from <code>qan::Graph</code> when a primitive creation request happen: a visual item with a specific style is then automatically created.</p> <p>Creation of a custom graph (MyGraph) with custom node (MyNode) and a dedicated visual item (MyNodeItem) could be achieved with the following architecture:</p> <p></p> <p>Factories have to be redefined in primitive subclasses:</p> <ul> <li><code>static QQmlComponent* delegate(QQmlEngine&amp; engine) noexcept</code>: Return a (usually singleton) QML component that will be used for primitive visual delegate.</li> <li><code>static qan::NodeStyle* style() noexcept</code>: Return a (usually singleton) style used as primitive default style.</li> </ul> <p>Custom content is then created from a specialized <code>qan::Graph</code> class:</p> <pre><code>// class MyGraph : public qan::Graph ...\n\nqan::Node* MyGraph::insertMyNode() noexcept {\n  return insertNode&lt;MyNode&gt;()\n}\n</code></pre> <pre><code>// In a custom MyNode.cpp defining MyNode (inheriting from qan::Node)\nQQmlComponent*  MyNode::delegate(QQmlEngine&amp; engine) noexcept\n{\nstatic std::unique_ptr&lt;QQmlComponent&gt;   MyNode_delegate;\n    if (!MyNode_delegate)\n            CustomRectNode_delegate = std::make_unique&lt;QQmlComponent&gt;(&amp;engine, \"qrc:/MyNode.qml\");\n    return CustomRectNode_delegate.get();\n}\n\nqan::NodeStyle* MyNode::style() noexcept\n{\n    static std::unique_ptr&lt;qan::NodeStyle&gt;  MyNode_style;\n    if (!MyNode_style) {\n        MyNode_style = std::make_unique&lt;qan::NodeStyle&gt;();\n        MyNode_style-&gt;setBackColor(QColor(\"#ff29fc\"));      // Initialize primitive default style here\n    }\n    return MyNode_style.get();\n}\n</code></pre> <p>Selection, visual connection and navigation will works out of the box for custom primitives (either nodes, edges or groups).</p>"},{"location":"advanced.html#insertion-of-non-visual-content","title":"Insertion of non Visual Content","text":"<p>Non visual edge or node could be used in graph to model complex topologies or add internal non-visual logic with:</p> <ul> <li><code>qan::Graph::insertNonVisualNode&lt;&gt;()</code>: default graph <code>nodeDelegate</code> will no be used, custom node <code>delegate()</code> may be oeither undefined or return nullptr.</li> <li><code>qan::Graph::insertNonVisualEdge&lt;&gt;(source, destination)</code>: Edge could be a regular node -&gt; node edge or an oriented hyper edge node -&gt; edge.</li> </ul>"},{"location":"advanced.html#observation-of-topological-modifications","title":"Observation of Topological Modifications","text":"<p>QuickQanava provide a full observation interface with the qan::Behaviour concept to react when underlying graph topology is modified. All primitives (nodes, edges or groups) could define custom behaviours to observe and react to topological changes.</p> <ul> <li><code>qan::NodeBehaviour</code>: </li> </ul> <p>A behaviour could then be registered using: <code>registerBehaviour()</code> method in <code>qan::Node</code>.</p> <pre><code>#include &lt;QuickQanava&gt;\n\nclass CustomBehaviour : public qan::NodeBehaviour\n{\n  Q_OBJECT\npublic:\n  explicit NodeBehaviour(QObject* parent = nullptr) :\n     qan::NodeBehaviour{\"Custom Behaviour\", parent} { }\n  virtual ~NodeBehaviour() override { /* Nil */ } \n  NodeBehaviour(const NodeBehaviour&amp;) = delete;\nprotected:\n  virtual void  inNodeInserted(qan::Node&amp; inNode, qan::Edge&amp; edge) noexcept override;\n  virtual void  inNodeRemoved(qan::Node&amp; inNode, qan::Edge&amp; edge) noexcept override;\n};\n</code></pre> <p>Such a custom node behaviour could be installed with the following code:</p> <pre><code>{\n  qan::Graph graph;\n  auto node = graph.insertNode();\n  node-&gt;attachBehaviour(std::make_unique&lt;CustomBehaviour&gt;());\n  // node will now react when an in node is inserted or removed\n  auto source = graph.insertNode();\n  auto edge = graph.insertEdge(source, node);   // CustomBehaviour::Inserted() called\n  graph.removeEdge(edge);                       // CustomBehaviour::inNodeRemoved() called\n}\n</code></pre> <p>Methods <code>inNodeInserted()</code> and <code>inNodeRemoved()</code> are called automatically when an in node is inserted or removed on behaviour target node.</p> <p>Reference documentation:</p> <ul> <li>qan::NodeBehaviour</li> <li>qan::Node::installBehaviour()</li> </ul>"},{"location":"edges.html","title":"Edges","text":""},{"location":"edges.html#creating-edges","title":"Creating Edges","text":"<p>Edges are managed from <code>Qan.Graph</code> (QML) or <code>qan::Graph</code> (C++) interface, usually in graph <code>Component.onCompleted()</code> handler:</p> <ul> <li><code>Qan.Edge Qan.Graph.insertEdge(Qan.Node src, Qan.Node dst)</code>: Insert a directed edge from source node to destination node.</li> <li><code>Qan.Edge Qan.Graph.removeEdge(Qan.Edge)</code>:</li> </ul> <p>Connections between nodes could be added from QML using Qan.Graph.insertEdge() function, or from c++ with qan::Graph::insertEdge() method. Edges graphics appearance is configured trought their <code>style</code> property, more information on available edge style option is available in Styles section </p> <pre><code>Component.onCompleted: {    // Qan.Graph.Component.onCompleted()\n    var n1 = graph.insertNode()\n    n1.label = \"Hello World\"; n1.item.x=50; n1.item.y= 50\n    var n2 = graph.insertNode()\n    n2.label = \"Node 2\"; n2.item.x=200; n2.item.y= 125\n\n    var e = graph.insertEdge(n1, n2);\n    defaultEdgeStyle.lineType = Qan.EdgeStyle.Curved\n}\n</code></pre> <p></p> <p>Edges appearance could be tuned by changing default styles properties directly from QML with global variables <code>defaultEdgeStyle</code>, see the Style Management section for more options.</p> <p>Edge could be moved by mouse when <code>qan::EdgeItem::draggable</code> property is set to true, edge source and destination nodes will be moved with the edge (this is not the default behavior).</p>"},{"location":"edges.html#visual-creation-of-edges","title":"Visual creation of edges","text":""},{"location":"edges.html#visual-connectors","title":"Visual Connectors","text":"<p>QuickQanava allow visual connection of node with the <code>Qan.VisualConnector</code> component. Default visual connector is configured in <code>Qan.Graph</code> component using the following properties:</p> <ul> <li> <p><code>Qan.Graph.connectorEnabled</code> (bool): Set to true to enable visual connection of nodes (default to false).</p> </li> <li> <p><code>Qan.Graph.connectorEdgeColor</code> (color): Set the visual connector preview edge color (useful to have Light/Dark theme support, default to black).</p> </li> <li> <p><code>Qan.Graph.connectorCreateDefaultEdge</code> (bool, default to true): When set to false, default visual connector does not use Qan.Graph.insertEdge() to create edge, but instead emit <code>connectorRequestEdgeCreation()</code> signal to allow user to create custom edge be calling a user defined method on graph (<code>connectorEdgeInserted()</code> is not emitted).</p> </li> <li> <p><code>Qan.Graph.setConnectorSource</code> (node): Select the node that should host the current visual connector.</p> </li> </ul> <pre><code>Qan.GraphView {\n  id: graphView\n  anchors.fill: parent\n  graph : Qan.Graph {\n    connectorEnabled: true\n    connectorEdgeInserted: console.debug( \"Edge inserted between \" + src.label + \" and  \" + dst.label)\n    connectorEdgeColor: \"violet\"\n    connectorColor: \"lightblue\"\n  } // Qan.Graph\n} // Qan.GraphView\n</code></pre> <p></p> <p>The following notifications callbacks are available:</p> <ul> <li> <p>Signal <code>Qan.Graph.connectorEdgeInserted(edge)</code>: Emitted when the visual connector has been dragged on a destination node or edge to allow specific user configuration on created edge.</p> </li> <li> <p>Signal <code>Qan.Graph.connectorRequestEdgeCreation(src, dst)</code>: Emitted when the visual connector is dragged on a target with <code>createDefaultEdge</code> set to false: allow creation of custom edge (or any other action) by the user. Example:</p> </li> </ul> <pre><code>Qan.GraphView {\n  id: graphView\n  anchors.fill: parent\n  graph : Qan.Graph {\n    id: graph\n    connectorEnabled: true\n    connectorCreateDefaultEdge: false\n    onConnectorRequestEdgeCreation: { \n      // Do whatever you want here, for example: graph.insertEdge(src, dst)\n    }\n  } // Qan.Graph\n} // Qan.GraphView\n</code></pre> <p>Preventing the visual connector to be shown for specific nodes (for example to force user to use out port to create topology) is possible by setting the node item <code>Qan.NodeItem.connectable' property to false (See</code>qan::NodeItem::connectable` header documentation).</p> <p>Reference documentation: qan::Connector interface</p>"},{"location":"edges.html#custom-connectors","title":"Custom Connectors","text":"<p>Default connector component <code>Qan.Graph.connector</code> could be replaced by a user defined <code>Qan.VisualConnector</code> to customize connector behavior in more depth. It is possible to add multiple visuals connectors on the same node, using a connector to generate specific topologies (create edges with different concrete types) or select targets visually. Such an advanced use of custom connectors is demonstrated in 'connector' sample: https://github.com/cneben/QuickQanava/tree/master/samples/connector</p>"},{"location":"graph.html","title":"Graph Topology and Visualization","text":""},{"location":"graph.html#data-model","title":"Data Model","text":"<p>QuickQanava data model enforce a clear separation between description of topology and it's visual representation:</p> <ul> <li>Topology is defined from C++ or QML (with imperative Js) using the <code>qan::Graph</code> interface. </li> <li>Topology primitives returned by <code>createX()</code> or <code>insertX()</code> have a visual counterpart available trough their <code>getItem()</code> method or <code>item</code> property.</li> </ul> <p>To keep data-model simple and efficient, topology is defined in a imperative way in C++ code or in a QML <code>Component.onCompleted()</code> handler. Visual representation of graph topology is then managed from a view, usually in pure QML with <code>Qan.GraphView</code> component. The unique proxy for editing topology is <code>qan::Graph</code> class and it's QML interface <code>Qan.Graph</code>.</p> <p>Graph topology is internally modeled using adjacency lists, these lists are exposed to QML and C++ with Qt abstract item models: a change in topology trigger a signal or a virtual method call in behavior observers. For example, any view connected to a node <code>outNodes</code> model is automatically updated when a directed edge is inserted from that node to another one.</p>"},{"location":"graph.html#quickqanava-initialization","title":"QuickQanava Initialization","text":"<p>QuickQanava should be initialized in your c++ main function:</p> <pre><code>#include &lt;QuickQanava&gt;\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n    QQuickStyle::setStyle(\"Material\");\n    QQmlApplicationEngine engine;\n    // Or in a custom QQuickView constructor:\n    QuickQanava::initialize();\n    engine.load( ... );\n    return app.exec();\n}\n</code></pre> <p>Then, in QML import QuickQanava: <pre><code>import QuickQanava 2.0 as Qan\nimport \"qrc:/QuickQanava\" as Qan\n</code></pre></p> <p>And create a <code>Qan.Graph</code> component to build a simple directed graph: <pre><code>Qan.Graph {\n    id: graph\n    anchors.fill: parent\n    Component.onCompleted: {\n        var n1 = graph.insertNode()\n        n1.label = \"Hello World\"\n    }\n}\n</code></pre></p>"},{"location":"graph.html#graph-view","title":"Graph View","text":"<p>A <code>Qan.Graph</code> or <code>qan::Graph</code> is a graphic item, but it is mainly used to define graph topology and should be embedded in a \"graph view\", following a (loose) MVC pattern to enable complete user interaction with the graph. A graph is binded to a view trough the <code>Qan.GraphView.graph</code> property:</p> <pre><code>Qan.GraphView {\n  id: graphView\n  anchors.fill: parent\n  navigable   : true\n  graph: Qan.Graph {\n      id: topology\n    } // Qan.Graph: topology\n} // Qan.GraphView\n</code></pre> <p>Binding a <code>Qan.Graph</code> component to <code>graph</code> property of a <code>Qan.GraphView</code> item allow navigation using mouse panning and zooming, navigation could be disabled by setting the <code>QanGraph.navigable</code> property to false (it default to true).</p> <p>There is more options for customizing how the view is rendered:</p> <p></p> <ul> <li><code>Qan.Graph.connectorColor</code>: Visual edge creation tool 'handler' color (default to dodgerblue).</li> <li><code>Qan.Graph.selectionColor</code>: Selection rect color (available for nodes and groups).</li> <li><code>Qan.GraphView.resizeHandlerColor</code>: Bottom right corner resize handler color.</li> <li><code>Qan.GraphView.resizeHandlerOpacity</code>, <code>resizeHandlerRadius</code>, <code>resizeHandlerWidth</code> and <code>resizeHandlerSize</code>: More options for bottom right corner resize handler configuration.</li> <li><code>Qan.GraphView.gridThickColor</code>: Grid major thick color (works for both point and line grids).</li> </ul> <p>For a more detailed description, see Material Styling</p>"},{"location":"graph.html#grid","title":"Grid","text":"<p>Grid could be configured with <code>Qan.GraphView.grid</code> property, only line grid is supported (see <code>Qan.LineGrid</code> component, <code>Qan.PointGrid</code> has been deprecated in 0.15.0), default grid is drawn with orthogonal lines.</p> <pre><code>import QuickQanava          2.0 as Qan\nimport \"qrc:/QuickQanava\"   as Qan\n\nQan.GraphView {\n  id: graphView\n  anchors.fill: parent\n  graph: Qan.Graph {\n      gridThickColor: \"lightgrey\"\n      grid: Qan.LineGrid{ \n        gridScale: 50\n        gridMajor: 5\n      }\n    } // Qan.Graph: graph\n} // Qan.GraphView\n</code></pre> <p>Grid appearance is configurable using the following abstract interface working for both points and lines grids:</p> <ul> <li><code>gridScale</code>: Interval in points between lines or points.</li> <li><code>gridMajor</code>: Number of thicks between major points or lines (for example for lines, setting <code>gridMajor</code> to 5.0 means that a major strong line will be drawn every 5 grid tiles).</li> <li><code>gridWidth</code>: size in points, either grid points or line width.</li> <li><code>thickColor</code>: Color for points or lines.</li> </ul> Qan.PointGrid (deprecated) Qan.LineGrid <p>As of 20180602, grid support is still under development, see issues 33 and 25. Snap to grid is also unsupported, contributions are welcome !</p>"},{"location":"installation.html","title":"QuickQanava Quick Start","text":"<p>Starting from version 2.4.0, QuickQanava is now a fully static library. It is recommended to install it from a Git submodule using CMake.</p> <ul> <li><code>CMake</code>: For Qt6, can be used trough <code>add_subdirectory()</code> or ExternalProject_Add()</li> </ul>"},{"location":"installation.html#using-from-external-projects-with-cmake","title":"Using from external projects with CMake","text":"<p>The recommended way of using QuickQanava is to include the library directly as a GIT submodule in your project:</p> <pre><code># Install QuickQanava as a GIT submodule\n$ git submodule add https://github.com/cneben/QuickQanava\n* git submodule update\n</code></pre> <p>From your <code>CMakeLists.txt</code>: <pre><code>add_subdirectory(PATH_TO_QUICKQANAVA_SUBMODULE)\n\ntarget_include_directories(my_project PUBLIC QuickQanava Qt${QT_VERSION_MAJOR}::QuickControls2)\n\ntarget_link_libraries(sample_advanced\n    QuickQanava\n    Qt${QT_VERSION_MAJOR}::Core\n    Qt${QT_VERSION_MAJOR}::Gui\n    Qt${QT_VERSION_MAJOR}::QuickControls2\n)\n</code></pre></p> <p>QuickQanava might also be included in CMake trough ExternalProject_Add() directly from GitHub.</p>"},{"location":"installation.html#building-samples-qmake-cmake-development","title":"Building samples qmake / CMake (development)","text":"<p>Using CMake (CMake &gt; 3.16):</p> <ol> <li> <p>Open CMakeLists.txt in QtCreator.</p> </li> <li> <p>for testing purposes, in 'Projects' panel, set <code>QUICK_QANAVA_BUILD_SAMPLES</code> option to <code>ON</code> in CMake configuration panel.</p> </li> <li> <p>Select a kit, build and launch samples.</p> </li> </ol> <p>Or build manually using CMake (CI):</p> <pre><code>$ cd QuickQanava\n$ mkdir build\n$ cd build\n\n# IF QT_DIR IS CONFIGURED AND QMAKE IN PATH\n$ cmake -DCMAKE_BUILD_TYPE=Release -DQUICK_QANAVA_BUILD_SAMPLES=OFF ..\n\n# IF QT DIR IS NOT CONFIGURED, CONFIGURE KIT MANUALLY\n$ cmake -DCMAKE_PREFIX_PATH=\"/path/to/Qt/5.15.14/gcc_64\" -DQT_QMAKE_EXECUTABLE=\"/path/to/Qt/6.6.1/gcc_64/bin/qmake\"  -DQUICK_QANAVA_BUILD_SAMPLES=OFF ../QuickQanava/\n\n$ cmake --build .\n# Then run the samples in ./samples\n\n# There is no make install\n</code></pre>"},{"location":"installation.html#dependencies","title":"Dependencies","text":"Dependency Mandatory Included in source tree Licence Google Test/Mock No No Permissive <ul> <li>Google Test is optional only to build and run tests .</li> </ul>"},{"location":"internals.html","title":"Library Internals (Contributors)","text":""},{"location":"internals.html#edge-geometry-management","title":"Edge Geometry Management","text":"<p>Generating edge geometry efficiently has a critical impact on performances, since moving a single node or groups might affect geometry for all adjacent edges. QuickQanava strategy is to cache all edge geometry in a specific moveable <code>qan::EdgeItem::GeometryCache</code> struct, and try to minimize changes when the cache is applied to a concrete edge in <code>qan::EdgeItem::updateItem()</code> method.</p> <p>Concrete visual item for the edge is a QML component inheriting from <code>qan::EdgeItem</code> (or <code>Qan.EdgeItem</code>). Default component is <code>Qan.Edge</code>, to ease creation of custom edge, the visual part of <code>Qan.Edge</code> is delegated to a \"QML template\", the default version is <code>Qan.EdgeTemplate</code>, it embed QtQuick.Shapes items and connect them to geometry properties in <code>qan::EdgeItem</code> (for example for \"curved edges\", a QtQuick.Shapes PathCubic is connected to properties <code>qan::EdgeItem::c1</code> and <code>c2</code> modelling bezier curve controls points.</p> <p></p> <ul> <li>dstA1/dstA2/dstA3 are generated in <code>EdgeItem::generateArrowGeometry()</code></li> </ul> <p>Source code:</p> <ul> <li>qanEdgeItem.h</li> </ul>"},{"location":"licence.html","title":"Licence","text":"<p>Copyright (c) 2008-2018, BA All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of the author or Destrat.io nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"nodes.html","title":"Defining Nodes","text":""},{"location":"nodes.html#topology","title":"Topology","text":""},{"location":"nodes.html#adding-content","title":"Adding content","text":"<p>Nodes are managed from <code>qan::Graph</code> (C++) graph or <code>Qan.Graph</code> (QML) interface. In QML, nodes are usually modified from <code>Qan.Graph Component.onCompleted()</code> function:</p> <ul> <li><code>Qan.Node Qan.Graph.insertNode()</code>: </li> <li><code>Qan.Group Qan.Graph.removeNode()</code>:</li> </ul> <p>All primitives (nodes, edges, groups) have both a \"topological and data\" aspect (Qan.Node, Qan.Edge, Qan.Group) and a visual counter part accessible trough their <code>item</code> property (usually a Qan.NodeItem, Qan.EdgeItem, Qan.GroupItem).</p> <pre><code>Qan.Graph {\n    id: graph\n    anchors.fill: parent\n    Component.onCompleted: {\n        var n1 = graph.insertNode()\n        n1.label = \"Hello World\"            // n1 encode node topology (it's a qan::Node)\n        n1.item.x = 50; n1.item.y = 50      // n1.item is n1 visual counterpart, usually a qan::NodeItem\n    }\n}\n</code></pre> <p></p> <p>Node appearance could be tuned by changing default styles properties directly from QML with global variable <code>defaultNodeStyle</code>, see the Style Management section for more options.</p>"},{"location":"nodes.html#docks-and-ports","title":"Docks and Ports","text":"<p>Docks and ports could be used to control how an edge is connected to source and destination node:</p> <ul> <li>A dock <code>Qan.DockItem</code> is a visual group of ports. QuickQanava define 4 ports identified by their position: Qan.NodeItem.Left / Qan.NodeItem.Top / Qan.NodeItem.Right / Qan.NodeItem.Bottom.</li> <li>A port <code>Qan.PortItem</code> is a graphical item attached to a node in a specific port that could receive in edge or \"emit\" out edges. A dock can have multiple ports with port.type beeing either PortItem.In (only input edge), PortItem.Out (only out edge) or PortItem.InOut.</li> </ul> <p>Docks and ports are managed trought the Qan.Graph interface:</p> <ul> <li><code>Qan.Graph.insertPort(node, orientation)</code>:  Insert a port on node at a given orientation and return a <code>Qan.PortItem</code>.</li> <li><code>Qan.Graph.bindEdgeDestination(edge, port)</code>: Bind an edge destination on a given port.</li> <li><code>Qan.Graph.bindEdgeSource(edge, port)</code>: Bind an edge source on a given port.</li> </ul> <p>Example of port insertion and binding to existing edges:</p> <pre><code>Component.onCompleted: {    // Qan.Graph.Component.onCompleted()\n    var n3 = graph.insertNode()\n    n3.label = \"N3\"; n3.item.x = 500; n3.item.y = 100\n    var n3p1 = graph.insertInPort(n3, Qan.NodeItem.Left);\n    n3p1.label = \"IN #1\"\n\n    var n3p1 = graph.insertInPort(n3, Qan.NodeItem.Top);\n    n3p1.label = \"OUT #1\"\n    var n3p2 = graph.insertInPort(n3, Qan.NodeItem.Bottom);\n    n3p2.label = \"OUT #2\"\n\n    var e = graph.insertEdge(n2, n3)\n    graph.bindEdgeDestination(e, n2p3)  // Bind our edge source to node N2 port P3 (OUT #1)\n    graph.bindEdgeDestination(e, n3p1)  // Bind our edge destination to node N3 port P1 (IN #1)\n}\n</code></pre> <p>(Note: Port/Dock API is still subject to change after v0.9.2)</p> <p></p> <p>Docks could be fully customized using QML delegates and custom node items, refer to customdocks.qml example in connector sample.</p>"},{"location":"nodes.html#node-resizing","title":"Node Resizing","text":"<p>Node resizing behaviour could be configured with the following Qan.NodeItem (or qan::NodeItem) properties:</p> <ul> <li><code>Qan.NodeItem.resizable</code> / <code>qan::NodeItem::setResizable()</code>: Enable or disable node item resizing (default to <code>true</code>, ie node is resizable).</li> <li><code>Qan.NodeItem.ratio</code> / <code>qan::NodeItem::setRatio()</code>: Set the node \"allowed\" resizing ratio when visual resizing is enabled. Ratio is witdh / height ratio that is allowed during visual resizing operations. Ratio conservation is disabled if <code>ratio</code> is &lt; 0. <code>ratio</code> default to -1, ie ratio is not conserved.</li> </ul> <pre><code>Component.onCompleted: {    // Qan.Graph.Component.onCompleted()\n    var n1 = graph.insertNode()\n    n1.item.resizable = false   // n1 is not resizable\n\n    var n2 = graph.insertNode()\n    n2.item.resizable = true    // n2 is resizable (setting to true is \n                                // not mandatory, it's the default behaviour)\n\n    n2.item.ratio = 0.5  // node resizing will maintain a width/height ratio \n                         // of 0.5, ie height will alays be half of width.\n}\n</code></pre> <p>Default resizer color could be configured in <code>Qan.GraphView</code> using the following properties:</p> <ul> <li><code>resizeHandlerColor</code> (color): Color of the visual drop node component (could be set to Material.accent for example)</li> </ul> <p>Node defining custom delegate resizing will be handled automatically by the framework. Complete customization of the resizing behaviour of custom nodes is possible using the <code>Qan.BottomRightResizer</code> component directly from custom delegates (See Bottom Right Resizer). </p>"},{"location":"nodes.html#observing-topology","title":"Observing Topology","text":"<p>Node related topology changes could be observed at graph or node level in the following ways:</p> <ul> <li>Overloading dedicated methods in <code>qan::Graph</code>: <code>onNodeInserted()</code>, <code>onNodeRemoved()</code>, default implementation is empty.</li> <li>Binding to properties: <ul> <li><code>qan::Graph::nodes::length</code>: Number of node actually registered in graph (observable QML property).</li> <li><code>qan::Node::inDegree</code>/ <code>qan::Node::outDegree</code>: In/out degree of a node updated in real-time, binded to a Qt Quick property useable from QML.</li> <li><code>qan::Node::inNodes</code>/ <code>qan::Node::outNodes</code>: Observable container of in/out nodes (in/out degree is inNodes.length/outNodes.length).</li> </ul> </li> <li>Binding to signals <code>qan::Graph::nodeInserted()</code> and <code>qan::Graph::nodeRemoved()</code>.</li> </ul> <p></p>"},{"location":"nodes.html#selection","title":"Selection","text":"<p>Selection can be modified at graph level just by changing the graph selection policy property <code>Qan.Graph.selectionPolicy</code>:</p> <ul> <li><code>Qan.AbstractGraph.NoSelection</code>: Selection will be disabled in the whole graph.</li> <li><code>Qan.AbstractGraph.SelectOnClick</code>: Node are selected when clicked, multiple selection is enabled when CTRL is pressed.</li> <li><code>Qan.AbstractGraph.SelectOnCtrlClick</code>: Node are selected only if CTRL is pressed when node is clicked (multiple selection is still available).</li> </ul> <p>Selection can also be configured with the following Qan.Graph properties:</p> <ul> <li><code>Qan.Graph.selectionColor</code> / <code>qan::Graph::setSelectionColor()</code>: Color for the node selection rectangle.</li> <li><code>Qan.Graph.selectionWeight</code> / <code>qan::Graph::setSelectionWeight()</code>: Border width of the node selection rectangle.</li> <li><code>Qan.Graph.selectionMargin</code> / <code>qan::Graph::setSelectionMargin()</code>: Margin between the node selection rectangle and the node content (selection weight is taken into account).</li> </ul> <p>All theses properties could be changed dynamically.</p> <p>Selection could also be disabled at node level by setting <code>Qan.Node.selectable</code> property to <code>false</code>, node become unselectable even if global graph selection policy <code>Qan.Graph.selectionPolicy</code> is set to something else than <code>NoSelection</code>.</p> <p>Current multiple selection (or single selection) is available through Qan.Graph <code>selectedNodes</code> property. <code>selectedNodes</code> is a list model, it can be used in any QML view, or iterated from C++ to read the current selection: <pre><code>// Viewing the currently selected nodes with a QML ListView:\nListView {\n    id: selectionListView\n    Layout.fillWidth: true; Layout.fillHeight: true\n    clip: true\n    model: graph.selectedNodes      // &lt;---------\n    spacing: 4; focus: true; flickableDirection : Flickable.VerticalFlick\n    highlightFollowsCurrentItem: false\n    highlight: Rectangle {\n        x: 0; y: ( selectionListView.currentItem !== null ? selectionListView.currentItem.y : 0 );\n        width: selectionListView.width; height: selectionListView.currentItem.height\n        color: \"lightsteelblue\"; opacity: 0.7; radius: 5\n    }\n    delegate: Item {\n        id: selectedNodeDelegate\n        width: ListView.view.width; height: 30;\n        Text { text: \"Label: \" + itemData.label }       // &lt;----- itemData is a Qan.Node, node \n                                                        // label could be accessed directly\n        MouseArea {\n            anchors.fill: selectedNodeDelegate\n            onClicked: { selectedNodeDelegate.ListView.view.currentIndex = index }\n        }\n    }\n}\n</code></pre></p> <p>In C++, <code>selectedNodes</code> could be iterated directly, the current node should be tested to ensure it is non nullptr, since the underlining model is thread-safe and could have been modified from another thread: <pre><code>    auto graph = std::make_unique&lt;qan::Graph&gt;();\n    for (auto node : graph-&gt;getSelectNodes()) {\n        if (node != nullptr)\n            node-&gt;doWhateverYouWant();\n    }\n    // Or better:\n    for (const auto node : qAsConst(graph-&gt;getSelectNodes())) {\n        if (node != nullptr)\n            node-&gt;doWhateverYouWantConst();\n    }\n</code></pre></p> <p>Example of <code>Qan.AbstractGraph.SelectOnClick</code> selection policy with multiple selection dragging inside a group:</p> <p></p>"},{"location":"nodes.html#defining-custom-nodes","title":"Defining Custom Nodes","text":"<p>Refer to <code>custom.qml</code> file in Nodes sample for more information regarding configuration and installation of specifics custom delegates for nodes and edges.</p> <p>When defining custom nodes with complex geometry (ie. non rectangular), there is multiple ways to take bounding shape generation into account :</p> <ul> <li> <p>Using the default behavior for rectangular node with <code>complexBoundingShape</code> set to false (default value), bounding shape is automatically generated on node width or height change in <code>generateDefaultBoundingShape()</code>.</p> </li> <li> <p>Using dedicated code by setting <code>complexBoundingShape</code> to true and with a call to \\c setBoundingShape() from a custom onRequestUpdateBoundingShape() signal handler.</p> </li> </ul> <p>Note that signal <code>requestUpdateBoundingShape</code> won't be emitted for non complex bounding shape. Optionally, you could choose to set complexBoundingShape to false and override <code>generateDefaultBoundingShape()</code> method.</p>"},{"location":"nodes.html#grouping-nodes","title":"Grouping Nodes","text":""},{"location":"nodes.html#default-groups","title":"Default Groups","text":"<p>Groups are a specific kind of nodes that can contains mutliple regular nodes. Groups are created using <code>Qan.Graph.insertGroup()</code> method. Nodes are ususally inserted into existing groups visually by dragging and dropping a node inside a group. Group topology could also be modified from C++ using <code>qan::Graph::groupNode()</code> and <code>qan::Graph::ungroupNode()</code> API.</p> <p>Group visual item (<code>Qan.GroupItem</code>) is accessible from <code>Qan.Group.item</code> property, the API is fully consistent with nodes. A group could have a custom label (editable directly from the default delegate using Quick Controls 2 text input) and could be collapsed visually using the <code>Qan.GroupItem.collapsed</code> property.</p> <p></p> <pre><code>Qan.Graph {\n  id: graph\n  objectName: \"graph\"\n  anchors.fill: parent\n\n  Component.onCompleted: {\n    var n1 = graph.insertNode()\n    n1.label = \"N1\"\n    var n2 = graph.insertNode()\n    n2.label = \"N2\"\n    var n3 = graph.insertNode()\n    n3.label = \"N3\"\n    graph.insertEdge(n1, n2)\n    graph.insertEdge(n2, n3)\n\n    var gg = graph.insertGroup();\n    gg.item.preferredGroupWidth = 300.\n    gg.item.preferredGroupHeight = 250.\n    gg.item.minimumGroupWidth = 200.\n    gg.item.minimumGroupHeight = 150.\n    gg.label = \"Group\"\n  }\n} // Qan.Graph: graph\n</code></pre> <p>The following configuration options are available for <code>Qan.Group</code>:</p> <ul> <li><code>Group.resizable</code> or <code>qan::GroupItem::resizable</code>: Enable or disable visual group resizing.</li> <li><code>Group.labelEditorVisible (QML only)</code>: Show or hide the group label visualization and edition visual component (label is editable by default).</li> <li><code>Group.expandButtonVisible (QML only)</code>: Show or hide the group default delegate expand/collapse button (button is visible by default).</li> </ul> <p>Group sizing is managed automatically by the framework to prevent resizing group below it's content <code>contentsRect</code>. Group size should not be modified directly trough standard quick items <code>width</code> and <code>height</code> properties, instead use:</p> <ul> <li><code>GroupItem.preferredGroupWidth</code> / <code>GroupItem.preferredGroupHeight</code>: Initial group size (should be used instead of setting group item width/height directly), default to (250x200).</li> <li><code>GroupItem.minimumGroupWidth</code> / <code>GroupItem.minimumGroupHeight</code>: Group can't be resized below specified width/height, default to (150x100).</li> </ul> <p>Refer to Group Sample for more detailled informations.</p>"},{"location":"nodes.html#custom-groups","title":"Custom Groups","text":"<p><code>GroupItem</code> is build using <code>Qan.RectGroupTemplate</code> template, a custom group delegate with full selection/resizing and styling support could easily be built using this template, see the Qan.Group component implementation for a demonstration.</p> <p>A group visual delegate could be built completely from scratch, by inheriting a component from <code>Qan.GroupItem</code> or directly from <code>qan::GroupItem</code> class, but the following interface must be configured to enable node drag and drop and complete integration in QuickQanava framework:</p> <ul> <li><code>Qan.GroupItem.container</code> or <code>qan::GroupItem::container</code> must be binded to a QuickItem acting as a group concrete container, otherwise visual drag and drop of nodes won't works (Mandatory).</li> <li>Custom group item should react to signals <code>onNodeDragEnter()</code> and <code>onNodeDragLeave()</code> when a candidate node is dragged above the group to send a visual feedback to the user (Optional).</li> </ul> <p>There is a complete demonstration for a custom group component without the use of default rectangular group template in 'cpp' sample: CustomGroup.qml and C++ class CustomGroup</p>"},{"location":"reference.html","title":"API Reference","text":""},{"location":"reference.html#api-reference","title":"API Reference","text":"<p>API reference is no longer available online, please run <code>doxygen</code> (&gt;= 1.8) command in <code>docs/reference</code> folder to generate your local copy (<code>dot</code> tools must be isntalled).</p>"},{"location":"samples.html","title":"QuickQanava Samples","text":"Feature nodes connector groups topology dataflow cpp Visual connector  (and custom connectors) Custom visual connector Selection  QML &amp; C++ Custom nodes QML Custom groups QML Custom nodes C++ Topology in C++"},{"location":"samples.html#custom-nodes-custom","title":"Custom Nodes: 'custom'","text":"<p>Demonstrate:</p> <ul> <li>How to define node with custom graphic content using QuickQanava node QML templates using custom delegates and <code>Qan.Graph.insertNode()</code> calls.</li> <li>How to use custom Canvas Qt Quick item for drawing node content with <code>Qan.CanvasNodeTemplate</code> component (see <code>DiamonNode.qml</code>).</li> <li>How to use existing Qt Quick item controls in QuickQanava nodes (see <code>ControlNode.qml</code>).</li> </ul> <p></p>"},{"location":"samples.html#navigable-area-navigable","title":"Navigable Area: 'navigable'","text":"<p>Demonstrate use of <code>qan::Navigable</code>. </p>"},{"location":"samples.html#groups-management-groups","title":"Groups Management: 'groups'","text":"<p>Demonstrate:</p> <ul> <li>How to create groups of node using <code>Qan.Graph.insertNode()</code> calls.</li> <li>How to interact with groups by catching <code>Qan.Graph.groupClicked()</code> and <code>Qan.Graph.groupRightClicked()</code> signals.</li> </ul> <p></p>"},{"location":"samples.html#style-management-style","title":"Style Management: 'style'","text":""},{"location":"samples.html#topology-sample-topology","title":"Topology Sample: 'topology'","text":"<p>Demonstrate:</p> <ul> <li>How to use <code>Qan.Graph.selectionPolicy</code>.</li> <li>How to use custom delegates to visualize nodes and edges in a ListView with <code>Qan.Graph.nodes</code> and <code>Qan.Graph.edges</code> properties.</li> </ul> <p></p>"},{"location":"styles.html","title":"Managing Styles","text":""},{"location":"styles.html#introduction","title":"Introduction","text":""},{"location":"styles.html#defining-styles","title":"Defining Styles","text":"<p>Three shortcut context variables are available from QML to access default styles: <code>defaultNodeStyle</code>, <code>defaultEdgeStyle</code>, <code>defaultGroupStyle</code>.</p> <p>QuickQanava provide a ready to use visual <code>Qan.StyleListView</code> component for visualizing, editing styles and dragging them visually on existing graph content. </p>"},{"location":"styles.html#node-style","title":"Node Style","text":"Property Description Default Sample <code>backRadius</code> Background rectangle border (corner) radius <code>4.0</code> <code>backOpacity</code> Background item opacity <code>0.85</code> (85% opaque)  1.0 opacity and 0.30 opacity <code>fillType</code> Background fill (<code>NodeStyle.FillGradient</code> or <code>NodeStyle.FillSolid</code>) <code>FillSolid</code> <code>fillType=Gradient</code> with <code>baseColor</code> 'violet' and <code>backColor</code> 'blue' <code>backColor</code> Background color <code>white</code> <code>baseColor</code> Background color used as base (ie top-left) color in gradient fill <code>white</code> <code>baseColor</code> 'violet' and <code>backColor</code> 'blue' <code>borderColor</code> Node border line color <code>black</code> <code>borderWidth</code> Node border line width <code>1.0</code> <code>effectType</code> Node effect, either <code>EffectNone</code>, <code>EffectShadow</code> (drop shadow) or <code>EffectGlow</code> <code>Qan.NodeStyle.EffectShadow</code> <code>effectType=EffectShadow</code> and <code>EffectGlow</code> <code>effectEnabled</code> Set to false to disable effect (much more efficient than setting <code>effectType</code> to <code>EffectNone</code> <code>true</code> <code>effectColor</code> Effect color (ie drop shadow or glow effect color) <code>darkgrey</code>  'violet' drop shadow <code>effectRadius</code> Effect radius <code>8.0</code>  4.0 and 20.0 drop shadow radius <code>effectOffset</code> Effect offset (used only for <code>NodeStyle.EffectShadow</code>) <code>4.0</code>  4.0 and 15.0 drop shadow offset"},{"location":"styles.html#material-styling","title":"Material Styling","text":"<p>There is easy to use properties shortcuts in <code>Qan.GraphView</code> and <code>Qan.Graph</code> to bind UI elements colors to a Qt Quick Controls 2 theme. The following sample show the minimal necessary binding to support Light and Dark mode when using the Qt Quick Material style:</p> <pre><code>import QtQuick.Controls.Material 2.1\nimport QuickQanava               2.0 as Qan\nimport \"qrc:/QuickQanava\"        as Qan\n\nQan.GraphView {\n    resizeHandlerColor: Material.accent\n    gridThickColor: Material.theme === Material.Dark ? \"#4e4e4e\" : \"#c1c1c1\"\n    topology: Qan.Graph {\n        // ...\n        selectionColor: Material.accent\n        connectorColor: Material.accent\n        connectorEdgeColor: Material.accent\n        // ...\n    } // Qan.Graph\n    // ...\n} // Qan.GraphView\n</code></pre>"},{"location":"utilities.html","title":"QuickQanava Utilities","text":""},{"location":"utilities.html#bottomrightresizer","title":"BottomRightResizer:","text":"<p>Qan.BottomRightResizer add a \"resize handler\" ont the bottom right of a target QML Item. Bottom right resizer component is automatically initialized in the QuickQanava::initialize method, it has no dependencies on QuickQanava and could be used in an isolated project just by copying its source code: <code>qanBottomRightResizer.h</code> and <code>qanBottomRightResizer.cpp</code> with a call to <code>qmlRegisterType&lt;qan::BottomRightResizer&gt;( \"YourModule\", 1, 0, \"BottomRightResizer\");</code></p> <p></p> <p></p> <pre><code>// From c++:\nqmlRegisterType&lt;qan::BottomRightResizer &gt;(\"YourModule\", 1, 0, \"BottomRightResizer\");\n\n // From QML:\nimport YourModule 1.0 as Qan\n\nItem {\n    id: targetItem\n    Qan.BottomRightResizer { target: targetItem }\n}\n</code></pre> <p>Resizer not necessarilly has to be in target (host) sibling, <code>Qan.BottomRightResizer</code> could be defined outside of target item hierarchy, for example to avoid corrupting the target <code>childrenRect</code> property. It is however more efficient to use the resizer as a target child (most common case).</p> <p>Right and bottom resizer are also available, see: <code>qan::RightResizer</code> and <code>qan::BottomResizer</code>.</p>"},{"location":"utilities.html#navigable","title":"Navigable:","text":"<p><code>qan::Navigable</code></p>"}]}