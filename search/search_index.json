{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"(Linux/g++6/Qt5.12.1 - OSX/Clang/Qt5.12.1) (Windows MSVC 2015 x64/Qt5.10.1) QuickQanava is alpha, interface may change before 1.0.0 release, but QuickQanava is already used extensively in production code. QuickQanava is licensed under BSD-3, specific features or support is available on demand: benoit@destrat.io Introduction \u00b6 QuickQanava is a C++14 library designed to display graphs and relational content in a QtQuick application. QuickQanava provide QML components and C++ classes to visualize medium-sized directed graphs in a C++/QML application. QuickQanava does not provide advanced layout algorithms, but rather focus on displaying relational content in advanced dynamic user interfaces (with DnD support, resizable content, visual connection of nodes). QuickQanava main repository is hosted on GitHub: https://github.com/cneben/quickqanava QuickQanava is primarily developed with Qt >= 5.13 with MSVC2015 and g++7. minimal required Qt version is Qt 5.10 . Project homepage: http://cneben.github.io/QuickQanava/index.html Please refer to Installation manual and Graph , Nodes and Graph sections for more information about installing and using QuickQanava. Gallery \u00b6 QuickQanava samples Node Grouping Visual Connection of Nodes Roadmap \u00b6 pre v2.0: Add full support for groups inside group (ie subgraphs). Update geometry creation interface and delegate management. Rewrite CMake configuration, add install step, use QML plugins. v2.1.x: Add support for direct visual dragging of port items. Add \"snap to grid\" support.","title":"QuickQanava"},{"location":"index.html#introduction","text":"QuickQanava is a C++14 library designed to display graphs and relational content in a QtQuick application. QuickQanava provide QML components and C++ classes to visualize medium-sized directed graphs in a C++/QML application. QuickQanava does not provide advanced layout algorithms, but rather focus on displaying relational content in advanced dynamic user interfaces (with DnD support, resizable content, visual connection of nodes). QuickQanava main repository is hosted on GitHub: https://github.com/cneben/quickqanava QuickQanava is primarily developed with Qt >= 5.13 with MSVC2015 and g++7. minimal required Qt version is Qt 5.10 . Project homepage: http://cneben.github.io/QuickQanava/index.html Please refer to Installation manual and Graph , Nodes and Graph sections for more information about installing and using QuickQanava.","title":"Introduction"},{"location":"index.html#gallery","text":"QuickQanava samples Node Grouping Visual Connection of Nodes","title":"Gallery"},{"location":"index.html#roadmap","text":"pre v2.0: Add full support for groups inside group (ie subgraphs). Update geometry creation interface and delegate management. Rewrite CMake configuration, add install step, use QML plugins. v2.1.x: Add support for direct visual dragging of port items. Add \"snap to grid\" support.","title":"Roadmap"},{"location":"advanced.html","text":"Advanced Use (C++) \u00b6 Using from C++ \u00b6 QuickQanava rely on and underlying QML engine to efficiently draw visual content using QML scene graph (eventually with HW OpenGL acceleration). While the API is almost 100% usable from C++, a QML engine must be initialized in the background for rendering topology, a minimal QuickQanava initialization from QML should thus create graph view and a graph topology components: // main.qml import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan ApplicationWindow { title : \"QuickQanava cpp API\" Qan . GraphView { anchors . fill : parent graph : Qan . Graph { objectName : \"graph\" anchors . fill : parent } // Qan.Graph: graph } } On the C++ side, a QML engine should be initialized before starting the application event loop: // main.cpp int main ( int argc , char ** argv ) { QGuiApplication app ( argc , argv ); QQmlApplicationEngine engine ; QuickQanava :: initialize ( & engine ); // Mandatory engine . load ( QUrl ( \"qrc:/main.qml\" )); // Custom \"synchronous\" topology initialization should be added here return app . exec (); } It is then easy to access Qan . Graph { objectName : \"graph\" } QML component trough it's qan :: Graph virtual interface: QPointer < CustomGraph > graph = nullptr ; for ( const auto rootObject : engine . rootObjects ()) { graph = qobject_cast < CustomGraph *> ( rootObject -> findChild < QQuickItem *> ( \"graph\" )); if ( graph ) break ; } if ( graph ) { // Go on } At this point, any modification should be done: Synchronously before application event loop is started using app.exec(). In signals handlers reacting to qan::Graph or qan::GraphView events such as nodeClicked() or groupClicked() and so on (See qan::Graph and qan::GraphView signals). Using behavior observers (See Behaviors section ). Please refer to the cpp sample and more specifically cpp_sample.cpp for a sample about using qan::Graph topology related methods. Defining Custom Topology \u00b6 QuickQanava topology is described using GTpo library. Topology is modelled using non visual objects modelling node ( qan::Node connected by directed edges ( qan::Edge eventually grouped in qan::Group . These non-visual objects (called primitives) are mapped to QML QQuickItem based visual items. Concrete QQuickItem are generated on demand using QML QQmlComponent objects. QuickQanava provide default delegates for all primitives, but custom delegate could be specify by providing an argument for all primitive creation functions: qan::Graph::insertNode() , qan::Graph::insertEdge() , qan::Graph::insertGroup() and their QML counterpart in Qan.Graph . Simple custom delegate mapping is described in custom nodes and custom groups sections. Primitives classes could be subclassed from c++ to provide specific customization. Mapping between non-visual topology primitive and their QtQuick counterpart is managed trought static singleton factories defined in qan::Node , qan::Edge and qan::Group . Theses factories are automatically called from qan::Graph when a primitive creation request happen: a visual item with a specific style is then automatically created. Creation of a custom graph (MyGraph) with custom node (MyNode) and a dedicated visual item (MyNodeItem) could be achieved with the following architecture: Factories have to be redefined in primitive subclasses: static QQmlComponent * delegate ( QQmlEngine & engine ) noexcept : Return a (usually singleton) QML component that will be used for primitive visual delegate. static qan :: NodeStyle * style () noexcept : Return a (usually singleton) style used as primitive default style. Custom content is then created from a specialized qan::Graph class: // class MyGraph : public qan::Graph ... qan :: Node * MyGraph::insertMyNode () noexcept { return insertNode < MyNode > () } // In a custom MyNode.cpp defining MyNode (inheriting from qan::Node) QQmlComponent * MyNode::delegate ( QQmlEngine & engine ) noexcept { static std :: unique_ptr < QQmlComponent > MyNode_delegate ; if ( ! MyNode_delegate ) CustomRectNode_delegate = std :: make_unique < QQmlComponent > ( & engine , \"qrc:/MyNode.qml\" ); return CustomRectNode_delegate . get (); } qan :: NodeStyle * MyNode::style () noexcept { static std :: unique_ptr < qan :: NodeStyle > MyNode_style ; if ( ! MyNode_style ) { MyNode_style = std :: make_unique < qan :: NodeStyle > (); MyNode_style -> setBackColor ( QColor ( \"#ff29fc\" )); // Initialize primitive default style here } return MyNode_style . get (); } Selection, visual connection and navigation will works out of the box for custom primitives (either nodes, edges or groups). Insertion of non Visual Content \u00b6 Non visual edge or node could be used in graph to model complex topologies or add internal non-visual logic with: qan :: Graph :: insertNonVisualNode <> () : default graph nodeDelegate will no be used, custom node delegate() may be oeither undefined or return nullptr. qan :: Graph :: insertNonVisualEdge <> ( source , destination ) : Edge could be a regular node -> node edge or an oriented hyper edge node -> edge. Observation of Topological Modifications \u00b6 QuickQanava provide a full observation interface with the qan::Behaviour concept to react when underlying graph topology is modified. All primitives (nodes, edges or groups) could define custom behaviours to observe and react to topological changes. qan::NodeBehaviour : A behaviour could then be registered using: registerBehaviour() method in qan::Node . #include <QuickQanava> class CustomBehaviour : public qan :: NodeBehaviour { Q_OBJECT public : explicit NodeBehaviour ( QObject * parent = nullptr ) : qan :: NodeBehaviour { \"Custom Behaviour\" , parent } { } virtual ~ NodeBehaviour () override { /* Nil */ } NodeBehaviour ( const NodeBehaviour & ) = delete ; protected : virtual void inNodeInserted ( qan :: Node & inNode , qan :: Edge & edge ) noexcept override ; virtual void inNodeRemoved ( qan :: Node & inNode , qan :: Edge & edge ) noexcept override ; }; Such a custom node behaviour could be installed with the following code: { qan :: Graph graph ; auto node = graph . insertNode (); node -> attachBehaviour ( std :: make_unique < CustomBehaviour > ()); // node will now react when an in node is inserted or removed auto source = graph . insertNode (); auto edge = graph . insertEdge ( source , node ); // CustomBehaviour::Inserted() called graph . removeEdge ( edge ); // CustomBehaviour::inNodeRemoved() called } Methods inNodeInserted() and inNodeRemoved() are called automatically when an in node is inserted or removed on behaviour target node. Reference documentation: qan::NodeBehaviour qan::Node::installBehaviour()","title":"Advanced use (C++)"},{"location":"advanced.html#advanced-use-c","text":"","title":"Advanced Use (C++)"},{"location":"advanced.html#using-from-c","text":"QuickQanava rely on and underlying QML engine to efficiently draw visual content using QML scene graph (eventually with HW OpenGL acceleration). While the API is almost 100% usable from C++, a QML engine must be initialized in the background for rendering topology, a minimal QuickQanava initialization from QML should thus create graph view and a graph topology components: // main.qml import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan ApplicationWindow { title : \"QuickQanava cpp API\" Qan . GraphView { anchors . fill : parent graph : Qan . Graph { objectName : \"graph\" anchors . fill : parent } // Qan.Graph: graph } } On the C++ side, a QML engine should be initialized before starting the application event loop: // main.cpp int main ( int argc , char ** argv ) { QGuiApplication app ( argc , argv ); QQmlApplicationEngine engine ; QuickQanava :: initialize ( & engine ); // Mandatory engine . load ( QUrl ( \"qrc:/main.qml\" )); // Custom \"synchronous\" topology initialization should be added here return app . exec (); } It is then easy to access Qan . Graph { objectName : \"graph\" } QML component trough it's qan :: Graph virtual interface: QPointer < CustomGraph > graph = nullptr ; for ( const auto rootObject : engine . rootObjects ()) { graph = qobject_cast < CustomGraph *> ( rootObject -> findChild < QQuickItem *> ( \"graph\" )); if ( graph ) break ; } if ( graph ) { // Go on } At this point, any modification should be done: Synchronously before application event loop is started using app.exec(). In signals handlers reacting to qan::Graph or qan::GraphView events such as nodeClicked() or groupClicked() and so on (See qan::Graph and qan::GraphView signals). Using behavior observers (See Behaviors section ). Please refer to the cpp sample and more specifically cpp_sample.cpp for a sample about using qan::Graph topology related methods.","title":"Using from C++"},{"location":"advanced.html#defining-custom-topology","text":"QuickQanava topology is described using GTpo library. Topology is modelled using non visual objects modelling node ( qan::Node connected by directed edges ( qan::Edge eventually grouped in qan::Group . These non-visual objects (called primitives) are mapped to QML QQuickItem based visual items. Concrete QQuickItem are generated on demand using QML QQmlComponent objects. QuickQanava provide default delegates for all primitives, but custom delegate could be specify by providing an argument for all primitive creation functions: qan::Graph::insertNode() , qan::Graph::insertEdge() , qan::Graph::insertGroup() and their QML counterpart in Qan.Graph . Simple custom delegate mapping is described in custom nodes and custom groups sections. Primitives classes could be subclassed from c++ to provide specific customization. Mapping between non-visual topology primitive and their QtQuick counterpart is managed trought static singleton factories defined in qan::Node , qan::Edge and qan::Group . Theses factories are automatically called from qan::Graph when a primitive creation request happen: a visual item with a specific style is then automatically created. Creation of a custom graph (MyGraph) with custom node (MyNode) and a dedicated visual item (MyNodeItem) could be achieved with the following architecture: Factories have to be redefined in primitive subclasses: static QQmlComponent * delegate ( QQmlEngine & engine ) noexcept : Return a (usually singleton) QML component that will be used for primitive visual delegate. static qan :: NodeStyle * style () noexcept : Return a (usually singleton) style used as primitive default style. Custom content is then created from a specialized qan::Graph class: // class MyGraph : public qan::Graph ... qan :: Node * MyGraph::insertMyNode () noexcept { return insertNode < MyNode > () } // In a custom MyNode.cpp defining MyNode (inheriting from qan::Node) QQmlComponent * MyNode::delegate ( QQmlEngine & engine ) noexcept { static std :: unique_ptr < QQmlComponent > MyNode_delegate ; if ( ! MyNode_delegate ) CustomRectNode_delegate = std :: make_unique < QQmlComponent > ( & engine , \"qrc:/MyNode.qml\" ); return CustomRectNode_delegate . get (); } qan :: NodeStyle * MyNode::style () noexcept { static std :: unique_ptr < qan :: NodeStyle > MyNode_style ; if ( ! MyNode_style ) { MyNode_style = std :: make_unique < qan :: NodeStyle > (); MyNode_style -> setBackColor ( QColor ( \"#ff29fc\" )); // Initialize primitive default style here } return MyNode_style . get (); } Selection, visual connection and navigation will works out of the box for custom primitives (either nodes, edges or groups).","title":"Defining Custom Topology"},{"location":"advanced.html#insertion-of-non-visual-content","text":"Non visual edge or node could be used in graph to model complex topologies or add internal non-visual logic with: qan :: Graph :: insertNonVisualNode <> () : default graph nodeDelegate will no be used, custom node delegate() may be oeither undefined or return nullptr. qan :: Graph :: insertNonVisualEdge <> ( source , destination ) : Edge could be a regular node -> node edge or an oriented hyper edge node -> edge.","title":"Insertion of non Visual Content"},{"location":"advanced.html#observation-of-topological-modifications","text":"QuickQanava provide a full observation interface with the qan::Behaviour concept to react when underlying graph topology is modified. All primitives (nodes, edges or groups) could define custom behaviours to observe and react to topological changes. qan::NodeBehaviour : A behaviour could then be registered using: registerBehaviour() method in qan::Node . #include <QuickQanava> class CustomBehaviour : public qan :: NodeBehaviour { Q_OBJECT public : explicit NodeBehaviour ( QObject * parent = nullptr ) : qan :: NodeBehaviour { \"Custom Behaviour\" , parent } { } virtual ~ NodeBehaviour () override { /* Nil */ } NodeBehaviour ( const NodeBehaviour & ) = delete ; protected : virtual void inNodeInserted ( qan :: Node & inNode , qan :: Edge & edge ) noexcept override ; virtual void inNodeRemoved ( qan :: Node & inNode , qan :: Edge & edge ) noexcept override ; }; Such a custom node behaviour could be installed with the following code: { qan :: Graph graph ; auto node = graph . insertNode (); node -> attachBehaviour ( std :: make_unique < CustomBehaviour > ()); // node will now react when an in node is inserted or removed auto source = graph . insertNode (); auto edge = graph . insertEdge ( source , node ); // CustomBehaviour::Inserted() called graph . removeEdge ( edge ); // CustomBehaviour::inNodeRemoved() called } Methods inNodeInserted() and inNodeRemoved() are called automatically when an in node is inserted or removed on behaviour target node. Reference documentation: qan::NodeBehaviour qan::Node::installBehaviour()","title":"Observation of Topological Modifications"},{"location":"edges.html","text":"Edges \u00b6 Creating Edges \u00b6 Edges are managed from Qan.Graph (QML) or qan::Graph (C++) interface, usually in graph Component.onCompleted() handler: Qan . Edge Qan . Graph . insertEdge ( Qan . Node src , Qan . Node dst ) : Insert a directed edge from source node to destination node. Qan . Edge Qan . Graph . removeEdge ( Qan . Edge ) : Connections between nodes could be added from QML using Qan.Graph.insertEdge() function, or from c++ with qan::Graph::insertEdge() method. Edges graphics appearance is configured trought their style property, more information on available edge style option is available in Styles section Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n1 = graph . insertNode () n1 . label = \"Hello World\" ; n1 . item . x = 50 ; n1 . item . y = 50 var n2 = graph . insertNode () n2 . label = \"Node 2\" ; n2 . item . x = 200 ; n2 . item . y = 125 var e = graph . insertEdge ( n1 , n2 ); defaultEdgeStyle . lineType = Qan . EdgeStyle . Curved } Edges appearance could be tuned by changing default styles properties directly from QML with global variables defaultEdgeStyle , see the Style Management section for more options. Edge could be moved by mouse when qan::EdgeItem::draggable property is set to true, edge source and destination nodes will be moved with the edge (this is not the default behavior). Visual creation of edges \u00b6 Visual Connectors \u00b6 QuickQanava allow visual connection of node with the Qan.VisualConnector component. Default visual connector is configured in Qan.Graph component using the following properties: Qan.Graph.connectorEnabled (bool): Set to true to enable visual connection of nodes (default to false). Qan.Graph.connectorEdgeColor (color): Set the visual connector preview edge color (useful to have Light/Dark theme support, default to black). Qan.Graph.connectorCreateDefaultEdge (bool, default to true): When set to false, default visual connector does not use Qan.Graph.insertEdge() to create edge, but instead emit connectorRequestEdgeCreation() signal to allow user to create custom edge be calling a user defined method on graph ( connectorEdgeInserted() is not emitted). Qan.Graph.setConnectorSource (node): Select the node that should host the current visual connector. Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { connectorEnabled : true connectorEdgeInserted : console . debug ( \"Edge inserted between \" + src . label + \" and \" + dst . label ) connectorEdgeColor : \"violet\" connectorColor : \"lightblue\" } // Qan.Graph } // Qan.GraphView The following notifications callbacks are available: Signal Qan.Graph.connectorEdgeInserted(edge) : Emitted when the visual connector has been dragged on a destination node or edge to allow specific user configuration on created edge. Signal Qan.Graph.connectorRequestEdgeCreation(src, dst) : Emitted when the visual connector is dragged on a target with createDefaultEdge set to false: allow creation of custom edge (or any other action) by the user. Example: Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { id : graph connectorEnabled : true connectorCreateDefaultEdge : false onConnectorRequestEdgeCreation : { // Do whatever you want here, for example: graph.insertEdge(src, dst) } } // Qan.Graph } // Qan.GraphView Preventing the visual connector to be shown for specific nodes (for example to force user to use out port to create topology) is possible by setting the node item Qan.NodeItem.connectable' property to false (See qan::NodeItem::connectable` header documentation). Reference documentation: qan::Connector interface Custom Connectors \u00b6 Default connector component Qan.Graph.connector could be replaced by a user defined Qan.VisualConnector to customize connector behavior in more depth. It is possible to add multiple visuals connectors on the same node, using a connector to generate specific topologies (create edges with different concrete types) or select targets visually. Such an advanced use of custom connectors is demonstrated in 'connector' sample: https://github.com/cneben/QuickQanava/tree/master/samples/connector","title":"Edges"},{"location":"edges.html#edges","text":"","title":"Edges"},{"location":"edges.html#creating-edges","text":"Edges are managed from Qan.Graph (QML) or qan::Graph (C++) interface, usually in graph Component.onCompleted() handler: Qan . Edge Qan . Graph . insertEdge ( Qan . Node src , Qan . Node dst ) : Insert a directed edge from source node to destination node. Qan . Edge Qan . Graph . removeEdge ( Qan . Edge ) : Connections between nodes could be added from QML using Qan.Graph.insertEdge() function, or from c++ with qan::Graph::insertEdge() method. Edges graphics appearance is configured trought their style property, more information on available edge style option is available in Styles section Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n1 = graph . insertNode () n1 . label = \"Hello World\" ; n1 . item . x = 50 ; n1 . item . y = 50 var n2 = graph . insertNode () n2 . label = \"Node 2\" ; n2 . item . x = 200 ; n2 . item . y = 125 var e = graph . insertEdge ( n1 , n2 ); defaultEdgeStyle . lineType = Qan . EdgeStyle . Curved } Edges appearance could be tuned by changing default styles properties directly from QML with global variables defaultEdgeStyle , see the Style Management section for more options. Edge could be moved by mouse when qan::EdgeItem::draggable property is set to true, edge source and destination nodes will be moved with the edge (this is not the default behavior).","title":"Creating Edges"},{"location":"edges.html#visual-creation-of-edges","text":"","title":"Visual creation of edges"},{"location":"edges.html#visual-connectors","text":"QuickQanava allow visual connection of node with the Qan.VisualConnector component. Default visual connector is configured in Qan.Graph component using the following properties: Qan.Graph.connectorEnabled (bool): Set to true to enable visual connection of nodes (default to false). Qan.Graph.connectorEdgeColor (color): Set the visual connector preview edge color (useful to have Light/Dark theme support, default to black). Qan.Graph.connectorCreateDefaultEdge (bool, default to true): When set to false, default visual connector does not use Qan.Graph.insertEdge() to create edge, but instead emit connectorRequestEdgeCreation() signal to allow user to create custom edge be calling a user defined method on graph ( connectorEdgeInserted() is not emitted). Qan.Graph.setConnectorSource (node): Select the node that should host the current visual connector. Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { connectorEnabled : true connectorEdgeInserted : console . debug ( \"Edge inserted between \" + src . label + \" and \" + dst . label ) connectorEdgeColor : \"violet\" connectorColor : \"lightblue\" } // Qan.Graph } // Qan.GraphView The following notifications callbacks are available: Signal Qan.Graph.connectorEdgeInserted(edge) : Emitted when the visual connector has been dragged on a destination node or edge to allow specific user configuration on created edge. Signal Qan.Graph.connectorRequestEdgeCreation(src, dst) : Emitted when the visual connector is dragged on a target with createDefaultEdge set to false: allow creation of custom edge (or any other action) by the user. Example: Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { id : graph connectorEnabled : true connectorCreateDefaultEdge : false onConnectorRequestEdgeCreation : { // Do whatever you want here, for example: graph.insertEdge(src, dst) } } // Qan.Graph } // Qan.GraphView Preventing the visual connector to be shown for specific nodes (for example to force user to use out port to create topology) is possible by setting the node item Qan.NodeItem.connectable' property to false (See qan::NodeItem::connectable` header documentation). Reference documentation: qan::Connector interface","title":"Visual Connectors"},{"location":"edges.html#custom-connectors","text":"Default connector component Qan.Graph.connector could be replaced by a user defined Qan.VisualConnector to customize connector behavior in more depth. It is possible to add multiple visuals connectors on the same node, using a connector to generate specific topologies (create edges with different concrete types) or select targets visually. Such an advanced use of custom connectors is demonstrated in 'connector' sample: https://github.com/cneben/QuickQanava/tree/master/samples/connector","title":"Custom Connectors"},{"location":"graph.html","text":"Graph Topology and Visualization \u00b6 Data Model \u00b6 QuickQanava data model enforce a clear separation between description of topology and it's visual representation: Topology is defined from C++ or QML (with imperative Js) using the qan::Graph interface. Topology primitives returned by createX() or insertX() have a visual counterpart available trough their getItem() method or item property. To keep data-model simple and efficient, topology is defined in a imperative way in C++ code or in a QML Component.onCompleted() handler. Visual representation of graph topology is then managed from a view, usually in pure QML with Qan.GraphView component. The unique proxy for editing topology is qan::Graph class and it's QML interface Qan.Graph . Graph topology is internally modeled using adjacency lists , these lists are exposed to QML and C++ with Qt abstract item models: a change in topology trigger a signal or a virtual method call in behavior observers. For example, any view connected to a node outNodes model is automatically updated when a directed edge is inserted from that node to another one. QuickQanava Initialization \u00b6 QuickQanava should be initialized in your c++ main function: #include <QuickQanava> int main ( int argc , char * argv []) { QGuiApplication app ( argc , argv ); QQuickStyle :: setStyle ( \"Material\" ); QQmlApplicationEngine engine ; // Or in a custom QQuickView constructor: QuickQanava :: initialize (); engine . load ( ... ); return app . exec (); } Then, in QML import QuickQanava: import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan And create a Qan.Graph component to build a simple directed graph: Qan . Graph { id : graph anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"Hello World\" } } Graph View \u00b6 A Qan.Graph or qan :: Graph is a graphic item, but it is mainly used to define graph topology and should be embedded in a \"graph view\", following a (loose) MVC pattern to enable complete user interaction with the graph. A graph is binded to a view trough the Qan.GraphView.graph property: Qan . GraphView { id : graphView anchors . fill : parent navigable : true graph : Qan . Graph { id : topology } // Qan.Graph: topology } // Qan.GraphView Binding a Qan.Graph component to graph property of a Qan.GraphView item allow navigation using mouse panning and zooming, navigation could be disabled by setting the QanGraph.navigable property to false (it default to true). There is more options for customizing how the view is rendered: Qan . Graph . connectorColor : Visual edge creation tool 'handler' color (default to dodgerblue). Qan . Graph . selectionColor : Selection rect color (available for nodes and groups). Qan . GraphView . resizeHandlerColor : Bottom right corner resize handler color. Qan . GraphView . resizeHandlerOpacity , resizeHandlerRadius , resizeHandlerWidth and resizeHandlerSize : More options for bottom right corner resize handler configuration. Qan . GraphView . gridThickColor : Grid major thick color (works for both point and line grids). For a more detailed description, see Material Styling Grid \u00b6 Grid could be configured with Qan.GraphView.grid property, only line grid is supported (see Qan.LineGrid component, Qan.PointGrid has been deprecated in 0.15.0), default grid is drawn with orthogonal lines. import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { gridThickColor : \"lightgrey\" grid : Qan . LineGrid { gridScale : 50 gridMajor : 5 } } // Qan.Graph: graph } // Qan.GraphView Grid appearance is configurable using the following abstract interface working for both points and lines grids: gridScale : Interval in points between lines or points. gridMajor : Number of thicks between major points or lines (for example for lines, setting gridMajor to 5.0 means that a major strong line will be drawn every 5 grid tiles). gridWidth : size in points, either grid points or line width. thickColor : Color for points or lines. Qan.PointGrid (deprecated) Qan.LineGrid As of 20180602, grid support is still under development, see issues 33 and 25 . Snap to grid is also unsupported, contributions are welcome !","title":"Graph"},{"location":"graph.html#graph-topology-and-visualization","text":"","title":"Graph Topology and Visualization"},{"location":"graph.html#data-model","text":"QuickQanava data model enforce a clear separation between description of topology and it's visual representation: Topology is defined from C++ or QML (with imperative Js) using the qan::Graph interface. Topology primitives returned by createX() or insertX() have a visual counterpart available trough their getItem() method or item property. To keep data-model simple and efficient, topology is defined in a imperative way in C++ code or in a QML Component.onCompleted() handler. Visual representation of graph topology is then managed from a view, usually in pure QML with Qan.GraphView component. The unique proxy for editing topology is qan::Graph class and it's QML interface Qan.Graph . Graph topology is internally modeled using adjacency lists , these lists are exposed to QML and C++ with Qt abstract item models: a change in topology trigger a signal or a virtual method call in behavior observers. For example, any view connected to a node outNodes model is automatically updated when a directed edge is inserted from that node to another one.","title":"Data Model"},{"location":"graph.html#quickqanava-initialization","text":"QuickQanava should be initialized in your c++ main function: #include <QuickQanava> int main ( int argc , char * argv []) { QGuiApplication app ( argc , argv ); QQuickStyle :: setStyle ( \"Material\" ); QQmlApplicationEngine engine ; // Or in a custom QQuickView constructor: QuickQanava :: initialize (); engine . load ( ... ); return app . exec (); } Then, in QML import QuickQanava: import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan And create a Qan.Graph component to build a simple directed graph: Qan . Graph { id : graph anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"Hello World\" } }","title":"QuickQanava Initialization"},{"location":"graph.html#graph-view","text":"A Qan.Graph or qan :: Graph is a graphic item, but it is mainly used to define graph topology and should be embedded in a \"graph view\", following a (loose) MVC pattern to enable complete user interaction with the graph. A graph is binded to a view trough the Qan.GraphView.graph property: Qan . GraphView { id : graphView anchors . fill : parent navigable : true graph : Qan . Graph { id : topology } // Qan.Graph: topology } // Qan.GraphView Binding a Qan.Graph component to graph property of a Qan.GraphView item allow navigation using mouse panning and zooming, navigation could be disabled by setting the QanGraph.navigable property to false (it default to true). There is more options for customizing how the view is rendered: Qan . Graph . connectorColor : Visual edge creation tool 'handler' color (default to dodgerblue). Qan . Graph . selectionColor : Selection rect color (available for nodes and groups). Qan . GraphView . resizeHandlerColor : Bottom right corner resize handler color. Qan . GraphView . resizeHandlerOpacity , resizeHandlerRadius , resizeHandlerWidth and resizeHandlerSize : More options for bottom right corner resize handler configuration. Qan . GraphView . gridThickColor : Grid major thick color (works for both point and line grids). For a more detailed description, see Material Styling","title":"Graph View"},{"location":"graph.html#grid","text":"Grid could be configured with Qan.GraphView.grid property, only line grid is supported (see Qan.LineGrid component, Qan.PointGrid has been deprecated in 0.15.0), default grid is drawn with orthogonal lines. import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan Qan . GraphView { id : graphView anchors . fill : parent graph : Qan . Graph { gridThickColor : \"lightgrey\" grid : Qan . LineGrid { gridScale : 50 gridMajor : 5 } } // Qan.Graph: graph } // Qan.GraphView Grid appearance is configurable using the following abstract interface working for both points and lines grids: gridScale : Interval in points between lines or points. gridMajor : Number of thicks between major points or lines (for example for lines, setting gridMajor to 5.0 means that a major strong line will be drawn every 5 grid tiles). gridWidth : size in points, either grid points or line width. thickColor : Color for points or lines. Qan.PointGrid (deprecated) Qan.LineGrid As of 20180602, grid support is still under development, see issues 33 and 25 . Snap to grid is also unsupported, contributions are welcome !","title":"Grid"},{"location":"installation.html","text":"QuickQanava Quick Start \u00b6 Dependencies \u00b6 Dependency Mandatory Included in source tree Licence Google Test/Mock No No Permissive Google Test is optional only to build and run tests . Building from sources \u00b6 Get the latest QuickQanava sources: git clone https://github.com/cneben/QuickQanava cd QuickQanava QuickQanava could be used with either qmake or CMake build configuration system. QuickQanava could be used with either qmake or CMake build configuration system. qmake cmake Static build, no QML module, all resources are linked statically trough QRC Installable or embedable, QuickQanava is loaded using a QML module that need to be installed Using qmake: Open quickqanava.pro in QtCreator. Select a kit, build and launch samples. or (CMake > 3.5) Open CMakeLists.txt in QtCreator. In 'Projects' panel, set DQUICK_QANAVA_BUILD_SAMPLES option to true in CMake configuration panel. Select a kit, build and launch samples. Or manually using CMake: $ cd QuickQanava $ mkdir build $ cd build # IF QT_DIR IS CONFIGURED AND QMAKE IN PATH $ cmake -DCMAKE_BUILD_TYPE = Release -DQUICK_QANAVA_BUILD_SAMPLES = TRUE .. # IF QT DIR IS NOT CONFIGURED, CONFIGURE KIT MANUALLY $ cmake -DCMAKE_PREFIX_PATH = \"/home/b/Qt/5.11.0/gcc_64\" -DQT_QMAKE_EXECUTABLE = \"/home/b/Qt/5.11.0/gcc_64/bin/qmake\" -DQUICK_QANAVA_BUILD_SAMPLES = TRUE ../QuickQanava/ $ cmake --build . # Then run the samples in ./samples # Eventually make install Note that a previously installed \"QML plugin\" version of QuickQanava might interfere with a fully static build using direct .pri inclusion. Typical error message looks like: QQmlApplicationEngine failed to load component qrc:/nodes.qml:33 module \"QuickQanava\" plugin \"quickqanavaplugin\" not found QuickQanava and QuickContainers plugins directories could be removed manually from $QTDIR\\..\\qml to fix the problem (ex: rm -rf '~/Qt/5.11.1/gcc_64/qml/QuickQanava'). Using from external projects \u00b6 The recommended way of using QuickQanava is to include the library directly as a GIT submodule in your project: # Install QuickQanava as a GIT submodule $ git submodule add https://github.com/cneben/QuickQanava * git submodule update Once GIT has finished downloading, QuickQanava project file could be included directly in your main qmake .pro file with the following two #include statements: #in your project main .pro qmake configuration file include ( $$ PWD/QuickQanava/src/quickqanava.pri )","title":"Installation"},{"location":"installation.html#quickqanava-quick-start","text":"","title":"QuickQanava Quick Start"},{"location":"installation.html#dependencies","text":"Dependency Mandatory Included in source tree Licence Google Test/Mock No No Permissive Google Test is optional only to build and run tests .","title":"Dependencies"},{"location":"installation.html#building-from-sources","text":"Get the latest QuickQanava sources: git clone https://github.com/cneben/QuickQanava cd QuickQanava QuickQanava could be used with either qmake or CMake build configuration system. QuickQanava could be used with either qmake or CMake build configuration system. qmake cmake Static build, no QML module, all resources are linked statically trough QRC Installable or embedable, QuickQanava is loaded using a QML module that need to be installed Using qmake: Open quickqanava.pro in QtCreator. Select a kit, build and launch samples. or (CMake > 3.5) Open CMakeLists.txt in QtCreator. In 'Projects' panel, set DQUICK_QANAVA_BUILD_SAMPLES option to true in CMake configuration panel. Select a kit, build and launch samples. Or manually using CMake: $ cd QuickQanava $ mkdir build $ cd build # IF QT_DIR IS CONFIGURED AND QMAKE IN PATH $ cmake -DCMAKE_BUILD_TYPE = Release -DQUICK_QANAVA_BUILD_SAMPLES = TRUE .. # IF QT DIR IS NOT CONFIGURED, CONFIGURE KIT MANUALLY $ cmake -DCMAKE_PREFIX_PATH = \"/home/b/Qt/5.11.0/gcc_64\" -DQT_QMAKE_EXECUTABLE = \"/home/b/Qt/5.11.0/gcc_64/bin/qmake\" -DQUICK_QANAVA_BUILD_SAMPLES = TRUE ../QuickQanava/ $ cmake --build . # Then run the samples in ./samples # Eventually make install Note that a previously installed \"QML plugin\" version of QuickQanava might interfere with a fully static build using direct .pri inclusion. Typical error message looks like: QQmlApplicationEngine failed to load component qrc:/nodes.qml:33 module \"QuickQanava\" plugin \"quickqanavaplugin\" not found QuickQanava and QuickContainers plugins directories could be removed manually from $QTDIR\\..\\qml to fix the problem (ex: rm -rf '~/Qt/5.11.1/gcc_64/qml/QuickQanava').","title":"Building from sources"},{"location":"installation.html#using-from-external-projects","text":"The recommended way of using QuickQanava is to include the library directly as a GIT submodule in your project: # Install QuickQanava as a GIT submodule $ git submodule add https://github.com/cneben/QuickQanava * git submodule update Once GIT has finished downloading, QuickQanava project file could be included directly in your main qmake .pro file with the following two #include statements: #in your project main .pro qmake configuration file include ( $$ PWD/QuickQanava/src/quickqanava.pri )","title":"Using from external projects"},{"location":"internals.html","text":"Library Internals (Contributors) \u00b6 Edge Geometry Management \u00b6 Generating edge geometry efficiently has a critical impact on performances, since moving a single node or groups might affect geometry for all adjacent edges . QuickQanava strategy is to cache all edge geometry in a specific moveable qan::EdgeItem::GeometryCache struct, and try to minimize changes when the cache is applied to a concrete edge in qan::EdgeItem::updateItem() method. Concrete visual item for the edge is a QML component inheriting from qan::EdgeItem (or Qan.EdgeItem ). Default component is Qan.Edge , to ease creation of custom edge, the visual part of Qan.Edge is delegated to a \"QML template\", the default version is Qan.EdgeTemplate , it embed QtQuick.Shapes items and connect them to geometry properties in qan::EdgeItem (for example for \"curved edges\", a QtQuick.Shapes PathCubic is connected to properties qan::EdgeItem::c1 and c2 modelling bezier curve controls points. dstA1/dstA2/dstA3 are generated in EdgeItem::generateArrowGeometry() Source code: qanEdgeItem.h","title":"Internals/Contributors"},{"location":"internals.html#library-internals-contributors","text":"","title":"Library Internals (Contributors)"},{"location":"internals.html#edge-geometry-management","text":"Generating edge geometry efficiently has a critical impact on performances, since moving a single node or groups might affect geometry for all adjacent edges . QuickQanava strategy is to cache all edge geometry in a specific moveable qan::EdgeItem::GeometryCache struct, and try to minimize changes when the cache is applied to a concrete edge in qan::EdgeItem::updateItem() method. Concrete visual item for the edge is a QML component inheriting from qan::EdgeItem (or Qan.EdgeItem ). Default component is Qan.Edge , to ease creation of custom edge, the visual part of Qan.Edge is delegated to a \"QML template\", the default version is Qan.EdgeTemplate , it embed QtQuick.Shapes items and connect them to geometry properties in qan::EdgeItem (for example for \"curved edges\", a QtQuick.Shapes PathCubic is connected to properties qan::EdgeItem::c1 and c2 modelling bezier curve controls points. dstA1/dstA2/dstA3 are generated in EdgeItem::generateArrowGeometry() Source code: qanEdgeItem.h","title":"Edge Geometry Management"},{"location":"licence.html","text":"Copyright \u00a9 2008-2018, BA All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the author or Destrat.io nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Licence"},{"location":"nodes.html","text":"Defining Nodes \u00b6 Topology \u00b6 Adding content \u00b6 Nodes are managed from qan::Graph (C++) graph or Qan.Graph (QML) interface. In QML, nodes are usually modified from Qan.Graph Component.onCompleted() function: Qan . Node Qan . Graph . insertNode () : Qan . Group Qan . Graph . removeNode () : All primitives (nodes, edges, groups) have both a \"topological and data\" aspect (Qan.Node, Qan.Edge, Qan.Group) and a visual counter part accessible trough their item property (usually a Qan.NodeItem, Qan.EdgeItem, Qan.GroupItem). Qan . Graph { id : graph anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"Hello World\" // n1 encode node topology (it's a qan::Node) n1 . item . x = 50 ; n1 . item . y = 50 // n1.item is n1 visual counterpart, usually a qan::NodeItem } } Node appearance could be tuned by changing default styles properties directly from QML with global variable defaultNodeStyle , see the Style Management section for more options. Docks and Ports \u00b6 Docks and ports could be used to control how an edge is connected to source and destination node: A dock Qan.DockItem is a visual group of ports. QuickQanava define 4 ports identified by their position: Qan.NodeItem.Left / Qan.NodeItem.Top / Qan.NodeItem.Right / Qan.NodeItem.Bottom. A port Qan.PortItem is a graphical item attached to a node in a specific port that could receive in edge or \"emit\" out edges. A dock can have multiple ports with port.type beeing either PortItem.In (only input edge), PortItem.Out (only out edge) or PortItem.InOut. Docks and ports are managed trought the Qan.Graph interface: Qan . Graph . insertPort ( node , orientation ) : Insert a port on node at a given orientation and return a Qan.PortItem . Qan . Graph . bindEdgeDestination ( edge , port ) : Bind an edge destination on a given port . Qan . Graph . bindEdgeSource ( edge , port ) : Bind an edge source on a given port . Example of port insertion and binding to existing edges: Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n3 = graph . insertNode () n3 . label = \"N3\" ; n3 . item . x = 500 ; n3 . item . y = 100 var n3p1 = graph . insertInPort ( n3 , Qan . NodeItem . Left ); n3p1 . label = \"IN #1\" var n3p1 = graph . insertInPort ( n3 , Qan . NodeItem . Top ); n3p1 . label = \"OUT #1\" var n3p2 = graph . insertInPort ( n3 , Qan . NodeItem . Bottom ); n3p2 . label = \"OUT #2\" var e = graph . insertEdge ( n2 , n3 ) graph . bindEdgeDestination ( e , n2p3 ) // Bind our edge source to node N2 port P3 (OUT #1) graph . bindEdgeDestination ( e , n3p1 ) // Bind our edge destination to node N3 port P1 (IN #1) } (Note: Port/Dock API is still subject to change after v0.9.2) Docks could be fully customized using QML delegates and custom node items, refer to customdocks.qml example in connector sample. Node Resizing \u00b6 Node resizing behaviour could be configured with the following Qan.NodeItem (or qan::NodeItem) properties: Qan . NodeItem . resizable / qan :: NodeItem :: setResizable () : Enable or disable node item resizing (default to true , ie node is resizable). Qan . NodeItem . ratio / qan :: NodeItem :: setRatio () : Set the node \"allowed\" resizing ratio when visual resizing is enabled. Ratio is witdh / height ratio that is allowed during visual resizing operations. Ratio conservation is disabled if ratio is < 0. ratio default to -1, ie ratio is not conserved. Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n1 = graph . insertNode () n1 . item . resizable = false // n1 is not resizable var n2 = graph . insertNode () n2 . item . resizable = true // n2 is resizable (setting to true is // not mandatory, it's the default behaviour) n2 . item . ratio = 0.5 // node resizing will maintain a width/height ratio // of 0.5, ie height will alays be half of width. } Default resizer color could be configured in Qan.GraphView using the following properties: resizeHandlerColor (color): Color of the visual drop node component (could be set to Material.accent for example) Node defining custom delegate resizing will be handled automatically by the framework. Complete customization of the resizing behaviour of custom nodes is possible using the Qan.BottomRightResizer component directly from custom delegates (See Bottom Right Resizer ). Observing Topology \u00b6 Node related topology changes could be observed at graph or node level in the following ways: Overloading dedicated methods in qan::Graph : onNodeInserted() , onNodeRemoved() , default implementation is empty. Binding to properties: qan::Graph::nodes::length : Number of node actually registered in graph (observable QML property). qan::Node::inDegree / qan::Node::outDegree : In/out degree of a node updated in real-time, binded to a Qt Quick property useable from QML. qan::Node::inNodes / qan::Node::outNodes : Observable container of in/out nodes (in/out degree is inNodes.length/outNodes.length). Binding to signals qan::Graph::nodeInserted() and qan::Graph::nodeRemoved() . Selection \u00b6 Selection can be modified at graph level just by changing the graph selection policy property Qan.Graph.selectionPolicy : Qan . AbstractGraph . NoSelection : Selection will be disabled in the whole graph. Qan . AbstractGraph . SelectOnClick : Node are selected when clicked, multiple selection is enabled when CTRL is pressed. Qan . AbstractGraph . SelectOnCtrlClick : Node are selected only if CTRL is pressed when node is clicked (multiple selection is still available). Selection can also be configured with the following Qan.Graph properties: Qan . Graph . selectionColor / qan :: Graph :: setSelectionColor () : Color for the node selection rectangle. Qan . Graph . selectionWeight / qan :: Graph :: setSelectionWeight () : Border width of the node selection rectangle. Qan . Graph . selectionMargin / qan :: Graph :: setSelectionMargin () : Margin between the node selection rectangle and the node content (selection weight is taken into account). All theses properties could be changed dynamically. Selection could also be disabled at node level by setting Qan.Node.selectable property to false , node become unselectable even if global graph selection policy Qan.Graph.selectionPolicy is set to something else than NoSelection . Current multiple selection (or single selection) is available through Qan.Graph selectedNodes property. selectedNodes is a list model, it can be used in any QML view, or iterated from C++ to read the current selection: // Viewing the currently selected nodes with a QML ListView: ListView { id : selectionListView Layout . fillWidth : true ; Layout . fillHeight : true clip : true model : graph . selectedNodes // <--------- spacing : 4 ; focus : true ; flickableDirection : Flickable . VerticalFlick highlightFollowsCurrentItem : false highlight : Rectangle { x : 0 ; y : ( selectionListView . currentItem !== null ? selectionListView . currentItem . y : 0 ); width : selectionListView . width ; height : selectionListView . currentItem . height color : \"lightsteelblue\" ; opacity : 0.7 ; radius : 5 } delegate : Item { id : selectedNodeDelegate width : ListView . view . width ; height : 30 ; Text { text : \"Label: \" + itemData . label } // <----- itemData is a Qan.Node, node // label could be accessed directly MouseArea { anchors . fill : selectedNodeDelegate onClicked : { selectedNodeDelegate . ListView . view . currentIndex = index } } } } In C++, selectedNodes could be iterated directly, the current node should be tested to ensure it is non nullptr, since the underlining model is thread-safe and could have been modified from another thread: auto graph = std :: make_unique < qan :: Graph > (); for ( auto node : graph -> getSelectNodes ()) { if ( node != nullptr ) node -> doWhateverYouWant (); } // Or better: for ( const auto node : qAsConst ( graph -> getSelectNodes ())) { if ( node != nullptr ) node -> doWhateverYouWantConst (); } Example of Qan.AbstractGraph.SelectOnClick selection policy with multiple selection dragging inside a group: Defining Custom Nodes \u00b6 Refer to custom.qml file in Nodes sample for more information regarding configuration and installation of specifics custom delegates for nodes and edges. When defining custom nodes with complex geometry (ie. non rectangular), there is multiple ways to take bounding shape generation into account : Using the default behavior for rectangular node with complexBoundingShape set to false (default value), bounding shape is automatically generated on node width or height change in generateDefaultBoundingShape() . Using dedicated code by setting complexBoundingShape to true and with a call to \\c setBoundingShape() from a custom onRequestUpdateBoundingShape() signal handler. Note that signal requestUpdateBoundingShape won't be emitted for non complex bounding shape. Optionally, you could choose to set complexBoundingShape to false and override generateDefaultBoundingShape() method. Grouping Nodes \u00b6 Default Groups \u00b6 Groups are a specific kind of nodes that can contains mutliple regular nodes. Groups are created using Qan . Graph . insertGroup () method. Nodes are ususally inserted into existing groups visually by dragging and dropping a node inside a group. Group topology could also be modified from C++ using qan::Graph::groupNode() and qan::Graph::ungroupNode() API. Group visual item ( Qan.GroupItem ) is accessible from Qan.Group.item property, the API is fully consistent with nodes. A group could have a custom label (editable directly from the default delegate using Quick Controls 2 text input) and could be collapsed visually using the Qan.GroupItem.collapsed property. Qan . Graph { id : graph objectName : \"graph\" anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"N1\" var n2 = graph . insertNode () n2 . label = \"N2\" var n3 = graph . insertNode () n3 . label = \"N3\" graph . insertEdge ( n1 , n2 ) graph . insertEdge ( n2 , n3 ) var gg = graph . insertGroup (); gg . item . preferredGroupWidth = 300. gg . item . preferredGroupHeight = 250. gg . item . minimumGroupWidth = 200. gg . item . minimumGroupHeight = 150. gg . label = \"Group\" } } // Qan.Graph: graph The following configuration options are available for Qan.Group : Group.resizable or qan::GroupItem::resizable : Enable or disable visual group resizing. Group.labelEditorVisible (QML only) : Show or hide the group label visualization and edition visual component (label is editable by default). Group.expandButtonVisible (QML only) : Show or hide the group default delegate expand/collapse button (button is visible by default). Group sizing is managed automatically by the framework to prevent resizing group below it's content contentsRect . Group size should not be modified directly trough standard quick items width and height properties, instead use: GroupItem.preferredGroupWidth / GroupItem.preferredGroupHeight : Initial group size (should be used instead of setting group item width/height directly), default to (250x200). GroupItem.minimumGroupWidth / GroupItem.minimumGroupHeight : Group can't be resized below specified width/height, default to (150x100). Refer to Group Sample for more detailled informations. Custom Groups \u00b6 GroupItem is build using Qan.RectGroupTemplate template, a custom group delegate with full selection/resizing and styling support could easily be built using this template, see the Qan.Group component implementation for a demonstration. A group visual delegate could be built completely from scratch, by inheriting a component from Qan.GroupItem or directly from qan :: GroupItem class, but the following interface must be configured to enable node drag and drop and complete integration in QuickQanava framework: Qan.GroupItem.container or qan :: GroupItem :: container must be binded to a QuickItem acting as a group concrete container, otherwise visual drag and drop of nodes won't works (Mandatory). Custom group item should react to signals onNodeDragEnter() and onNodeDragLeave() when a candidate node is dragged above the group to send a visual feedback to the user (Optional). There is a complete demonstration for a custom group component without the use of default rectangular group template in 'cpp' sample: CustomGroup.qml and C++ class CustomGroup","title":"Nodes/Groups"},{"location":"nodes.html#defining-nodes","text":"","title":"Defining Nodes"},{"location":"nodes.html#topology","text":"","title":"Topology"},{"location":"nodes.html#adding-content","text":"Nodes are managed from qan::Graph (C++) graph or Qan.Graph (QML) interface. In QML, nodes are usually modified from Qan.Graph Component.onCompleted() function: Qan . Node Qan . Graph . insertNode () : Qan . Group Qan . Graph . removeNode () : All primitives (nodes, edges, groups) have both a \"topological and data\" aspect (Qan.Node, Qan.Edge, Qan.Group) and a visual counter part accessible trough their item property (usually a Qan.NodeItem, Qan.EdgeItem, Qan.GroupItem). Qan . Graph { id : graph anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"Hello World\" // n1 encode node topology (it's a qan::Node) n1 . item . x = 50 ; n1 . item . y = 50 // n1.item is n1 visual counterpart, usually a qan::NodeItem } } Node appearance could be tuned by changing default styles properties directly from QML with global variable defaultNodeStyle , see the Style Management section for more options.","title":"Adding content"},{"location":"nodes.html#docks-and-ports","text":"Docks and ports could be used to control how an edge is connected to source and destination node: A dock Qan.DockItem is a visual group of ports. QuickQanava define 4 ports identified by their position: Qan.NodeItem.Left / Qan.NodeItem.Top / Qan.NodeItem.Right / Qan.NodeItem.Bottom. A port Qan.PortItem is a graphical item attached to a node in a specific port that could receive in edge or \"emit\" out edges. A dock can have multiple ports with port.type beeing either PortItem.In (only input edge), PortItem.Out (only out edge) or PortItem.InOut. Docks and ports are managed trought the Qan.Graph interface: Qan . Graph . insertPort ( node , orientation ) : Insert a port on node at a given orientation and return a Qan.PortItem . Qan . Graph . bindEdgeDestination ( edge , port ) : Bind an edge destination on a given port . Qan . Graph . bindEdgeSource ( edge , port ) : Bind an edge source on a given port . Example of port insertion and binding to existing edges: Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n3 = graph . insertNode () n3 . label = \"N3\" ; n3 . item . x = 500 ; n3 . item . y = 100 var n3p1 = graph . insertInPort ( n3 , Qan . NodeItem . Left ); n3p1 . label = \"IN #1\" var n3p1 = graph . insertInPort ( n3 , Qan . NodeItem . Top ); n3p1 . label = \"OUT #1\" var n3p2 = graph . insertInPort ( n3 , Qan . NodeItem . Bottom ); n3p2 . label = \"OUT #2\" var e = graph . insertEdge ( n2 , n3 ) graph . bindEdgeDestination ( e , n2p3 ) // Bind our edge source to node N2 port P3 (OUT #1) graph . bindEdgeDestination ( e , n3p1 ) // Bind our edge destination to node N3 port P1 (IN #1) } (Note: Port/Dock API is still subject to change after v0.9.2) Docks could be fully customized using QML delegates and custom node items, refer to customdocks.qml example in connector sample.","title":"Docks and Ports"},{"location":"nodes.html#node-resizing","text":"Node resizing behaviour could be configured with the following Qan.NodeItem (or qan::NodeItem) properties: Qan . NodeItem . resizable / qan :: NodeItem :: setResizable () : Enable or disable node item resizing (default to true , ie node is resizable). Qan . NodeItem . ratio / qan :: NodeItem :: setRatio () : Set the node \"allowed\" resizing ratio when visual resizing is enabled. Ratio is witdh / height ratio that is allowed during visual resizing operations. Ratio conservation is disabled if ratio is < 0. ratio default to -1, ie ratio is not conserved. Component . onCompleted : { // Qan.Graph.Component.onCompleted() var n1 = graph . insertNode () n1 . item . resizable = false // n1 is not resizable var n2 = graph . insertNode () n2 . item . resizable = true // n2 is resizable (setting to true is // not mandatory, it's the default behaviour) n2 . item . ratio = 0.5 // node resizing will maintain a width/height ratio // of 0.5, ie height will alays be half of width. } Default resizer color could be configured in Qan.GraphView using the following properties: resizeHandlerColor (color): Color of the visual drop node component (could be set to Material.accent for example) Node defining custom delegate resizing will be handled automatically by the framework. Complete customization of the resizing behaviour of custom nodes is possible using the Qan.BottomRightResizer component directly from custom delegates (See Bottom Right Resizer ).","title":"Node Resizing"},{"location":"nodes.html#observing-topology","text":"Node related topology changes could be observed at graph or node level in the following ways: Overloading dedicated methods in qan::Graph : onNodeInserted() , onNodeRemoved() , default implementation is empty. Binding to properties: qan::Graph::nodes::length : Number of node actually registered in graph (observable QML property). qan::Node::inDegree / qan::Node::outDegree : In/out degree of a node updated in real-time, binded to a Qt Quick property useable from QML. qan::Node::inNodes / qan::Node::outNodes : Observable container of in/out nodes (in/out degree is inNodes.length/outNodes.length). Binding to signals qan::Graph::nodeInserted() and qan::Graph::nodeRemoved() .","title":"Observing Topology"},{"location":"nodes.html#selection","text":"Selection can be modified at graph level just by changing the graph selection policy property Qan.Graph.selectionPolicy : Qan . AbstractGraph . NoSelection : Selection will be disabled in the whole graph. Qan . AbstractGraph . SelectOnClick : Node are selected when clicked, multiple selection is enabled when CTRL is pressed. Qan . AbstractGraph . SelectOnCtrlClick : Node are selected only if CTRL is pressed when node is clicked (multiple selection is still available). Selection can also be configured with the following Qan.Graph properties: Qan . Graph . selectionColor / qan :: Graph :: setSelectionColor () : Color for the node selection rectangle. Qan . Graph . selectionWeight / qan :: Graph :: setSelectionWeight () : Border width of the node selection rectangle. Qan . Graph . selectionMargin / qan :: Graph :: setSelectionMargin () : Margin between the node selection rectangle and the node content (selection weight is taken into account). All theses properties could be changed dynamically. Selection could also be disabled at node level by setting Qan.Node.selectable property to false , node become unselectable even if global graph selection policy Qan.Graph.selectionPolicy is set to something else than NoSelection . Current multiple selection (or single selection) is available through Qan.Graph selectedNodes property. selectedNodes is a list model, it can be used in any QML view, or iterated from C++ to read the current selection: // Viewing the currently selected nodes with a QML ListView: ListView { id : selectionListView Layout . fillWidth : true ; Layout . fillHeight : true clip : true model : graph . selectedNodes // <--------- spacing : 4 ; focus : true ; flickableDirection : Flickable . VerticalFlick highlightFollowsCurrentItem : false highlight : Rectangle { x : 0 ; y : ( selectionListView . currentItem !== null ? selectionListView . currentItem . y : 0 ); width : selectionListView . width ; height : selectionListView . currentItem . height color : \"lightsteelblue\" ; opacity : 0.7 ; radius : 5 } delegate : Item { id : selectedNodeDelegate width : ListView . view . width ; height : 30 ; Text { text : \"Label: \" + itemData . label } // <----- itemData is a Qan.Node, node // label could be accessed directly MouseArea { anchors . fill : selectedNodeDelegate onClicked : { selectedNodeDelegate . ListView . view . currentIndex = index } } } } In C++, selectedNodes could be iterated directly, the current node should be tested to ensure it is non nullptr, since the underlining model is thread-safe and could have been modified from another thread: auto graph = std :: make_unique < qan :: Graph > (); for ( auto node : graph -> getSelectNodes ()) { if ( node != nullptr ) node -> doWhateverYouWant (); } // Or better: for ( const auto node : qAsConst ( graph -> getSelectNodes ())) { if ( node != nullptr ) node -> doWhateverYouWantConst (); } Example of Qan.AbstractGraph.SelectOnClick selection policy with multiple selection dragging inside a group:","title":"Selection"},{"location":"nodes.html#defining-custom-nodes","text":"Refer to custom.qml file in Nodes sample for more information regarding configuration and installation of specifics custom delegates for nodes and edges. When defining custom nodes with complex geometry (ie. non rectangular), there is multiple ways to take bounding shape generation into account : Using the default behavior for rectangular node with complexBoundingShape set to false (default value), bounding shape is automatically generated on node width or height change in generateDefaultBoundingShape() . Using dedicated code by setting complexBoundingShape to true and with a call to \\c setBoundingShape() from a custom onRequestUpdateBoundingShape() signal handler. Note that signal requestUpdateBoundingShape won't be emitted for non complex bounding shape. Optionally, you could choose to set complexBoundingShape to false and override generateDefaultBoundingShape() method.","title":"Defining Custom Nodes"},{"location":"nodes.html#grouping-nodes","text":"","title":"Grouping Nodes"},{"location":"nodes.html#default-groups","text":"Groups are a specific kind of nodes that can contains mutliple regular nodes. Groups are created using Qan . Graph . insertGroup () method. Nodes are ususally inserted into existing groups visually by dragging and dropping a node inside a group. Group topology could also be modified from C++ using qan::Graph::groupNode() and qan::Graph::ungroupNode() API. Group visual item ( Qan.GroupItem ) is accessible from Qan.Group.item property, the API is fully consistent with nodes. A group could have a custom label (editable directly from the default delegate using Quick Controls 2 text input) and could be collapsed visually using the Qan.GroupItem.collapsed property. Qan . Graph { id : graph objectName : \"graph\" anchors . fill : parent Component . onCompleted : { var n1 = graph . insertNode () n1 . label = \"N1\" var n2 = graph . insertNode () n2 . label = \"N2\" var n3 = graph . insertNode () n3 . label = \"N3\" graph . insertEdge ( n1 , n2 ) graph . insertEdge ( n2 , n3 ) var gg = graph . insertGroup (); gg . item . preferredGroupWidth = 300. gg . item . preferredGroupHeight = 250. gg . item . minimumGroupWidth = 200. gg . item . minimumGroupHeight = 150. gg . label = \"Group\" } } // Qan.Graph: graph The following configuration options are available for Qan.Group : Group.resizable or qan::GroupItem::resizable : Enable or disable visual group resizing. Group.labelEditorVisible (QML only) : Show or hide the group label visualization and edition visual component (label is editable by default). Group.expandButtonVisible (QML only) : Show or hide the group default delegate expand/collapse button (button is visible by default). Group sizing is managed automatically by the framework to prevent resizing group below it's content contentsRect . Group size should not be modified directly trough standard quick items width and height properties, instead use: GroupItem.preferredGroupWidth / GroupItem.preferredGroupHeight : Initial group size (should be used instead of setting group item width/height directly), default to (250x200). GroupItem.minimumGroupWidth / GroupItem.minimumGroupHeight : Group can't be resized below specified width/height, default to (150x100). Refer to Group Sample for more detailled informations.","title":"Default Groups"},{"location":"nodes.html#custom-groups","text":"GroupItem is build using Qan.RectGroupTemplate template, a custom group delegate with full selection/resizing and styling support could easily be built using this template, see the Qan.Group component implementation for a demonstration. A group visual delegate could be built completely from scratch, by inheriting a component from Qan.GroupItem or directly from qan :: GroupItem class, but the following interface must be configured to enable node drag and drop and complete integration in QuickQanava framework: Qan.GroupItem.container or qan :: GroupItem :: container must be binded to a QuickItem acting as a group concrete container, otherwise visual drag and drop of nodes won't works (Mandatory). Custom group item should react to signals onNodeDragEnter() and onNodeDragLeave() when a candidate node is dragged above the group to send a visual feedback to the user (Optional). There is a complete demonstration for a custom group component without the use of default rectangular group template in 'cpp' sample: CustomGroup.qml and C++ class CustomGroup","title":"Custom Groups"},{"location":"reference.html","text":"API Reference \u00b6 API reference is no longer available online, please run doxygen (>= 1.8) command in docs/reference folder to generate your local copy ( dot tools must be isntalled).","title":"API Reference"},{"location":"reference.html#api-reference","text":"API reference is no longer available online, please run doxygen (>= 1.8) command in docs/reference folder to generate your local copy ( dot tools must be isntalled).","title":"API Reference"},{"location":"samples.html","text":"QuickQanava Samples \u00b6 Feature nodes connector groups topology dataflow cpp Visual connector (and custom connectors) Custom visual connector Selection QML & C++ Custom nodes QML Custom groups QML Custom nodes C++ Topology in C++ Custom Nodes: 'custom' \u00b6 Demonstrate: How to define node with custom graphic content using QuickQanava node QML templates using custom delegates and Qan.Graph.insertNode() calls. How to use custom Canvas Qt Quick item for drawing node content with Qan.CanvasNodeTemplate component (see DiamonNode.qml ). How to use existing Qt Quick item controls in QuickQanava nodes (see ControlNode.qml ). Navigable Area: 'navigable' \u00b6 Demonstrate use of qan::Navigable . Groups Management: 'groups' \u00b6 Demonstrate: How to create groups of node using Qan.Graph.insertNode() calls. How to interact with groups by catching Qan.Graph.groupClicked() and Qan.Graph.groupRightClicked() signals. Style Management: 'style' \u00b6 Topology Sample: 'topology' \u00b6 Demonstrate: How to use Qan.Graph.selectionPolicy . How to use custom delegates to visualize nodes and edges in a ListView with Qan.Graph.nodes and Qan.Graph.edges properties.","title":"Samples"},{"location":"samples.html#quickqanava-samples","text":"Feature nodes connector groups topology dataflow cpp Visual connector (and custom connectors) Custom visual connector Selection QML & C++ Custom nodes QML Custom groups QML Custom nodes C++ Topology in C++","title":"QuickQanava Samples"},{"location":"samples.html#custom-nodes-custom","text":"Demonstrate: How to define node with custom graphic content using QuickQanava node QML templates using custom delegates and Qan.Graph.insertNode() calls. How to use custom Canvas Qt Quick item for drawing node content with Qan.CanvasNodeTemplate component (see DiamonNode.qml ). How to use existing Qt Quick item controls in QuickQanava nodes (see ControlNode.qml ).","title":"Custom Nodes: 'custom'"},{"location":"samples.html#navigable-area-navigable","text":"Demonstrate use of qan::Navigable .","title":"Navigable Area: 'navigable'"},{"location":"samples.html#groups-management-groups","text":"Demonstrate: How to create groups of node using Qan.Graph.insertNode() calls. How to interact with groups by catching Qan.Graph.groupClicked() and Qan.Graph.groupRightClicked() signals.","title":"Groups Management: 'groups'"},{"location":"samples.html#style-management-style","text":"","title":"Style Management: 'style'"},{"location":"samples.html#topology-sample-topology","text":"Demonstrate: How to use Qan.Graph.selectionPolicy . How to use custom delegates to visualize nodes and edges in a ListView with Qan.Graph.nodes and Qan.Graph.edges properties.","title":"Topology Sample: 'topology'"},{"location":"styles.html","text":"Managing Styles \u00b6 Introduction \u00b6 Defining Styles \u00b6 Three shortcut context variables are available from QML to access default styles: defaultNodeStyle , defaultEdgeStyle , defaultGroupStyle . QuickQanava provide a ready to use visual Qan.StyleListView component for visualizing, editing styles and dragging them visually on existing graph content. Node Style \u00b6 Property Description Default Sample backRadius Background rectangle border (corner) radius 4.0 backOpacity Background item opacity 0.85 (85% opaque) 1.0 opacity and 0.30 opacity fillType Background fill ( NodeStyle.FillGradient or NodeStyle.FillSolid ) FillSolid fillType=Gradient with baseColor 'violet' and backColor 'blue' backColor Background color white baseColor Background color used as base (ie top-left) color in gradient fill white baseColor 'violet' and backColor 'blue' borderColor Node border line color black borderWidth Node border line width 1.0 effectType Node effect, either EffectNone , EffectShadow (drop shadow) or EffectGlow Qan.NodeStyle.EffectShadow effectType=EffectShadow and EffectGlow effectEnabled Set to false to disable effect (much more efficient than setting effectType to EffectNone true effectColor Effect color (ie drop shadow or glow effect color) darkgrey 'violet' drop shadow effectRadius Effect radius 8.0 4.0 and 20.0 drop shadow radius effectOffset Effect offset (used only for NodeStyle.EffectShadow ) 4.0 4.0 and 15.0 drop shadow offset Material Styling \u00b6 There is easy to use properties shortcuts in Qan.GraphView and Qan.Graph to bind UI elements colors to a Qt Quick Controls 2 theme. The following sample show the minimal necessary binding to support Light and Dark mode when using the Qt Quick Material style: import QtQuick . Controls . Material 2.1 import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan Qan . GraphView { resizeHandlerColor : Material . accent gridThickColor : Material . theme === Material . Dark ? \"#4e4e4e\" : \"#c1c1c1\" topology : Qan . Graph { // ... selectionColor : Material . accent connectorColor : Material . accent connectorEdgeColor : Material . accent // ... } // Qan.Graph // ... } // Qan.GraphView","title":"Styles"},{"location":"styles.html#managing-styles","text":"","title":"Managing Styles"},{"location":"styles.html#introduction","text":"","title":"Introduction"},{"location":"styles.html#defining-styles","text":"Three shortcut context variables are available from QML to access default styles: defaultNodeStyle , defaultEdgeStyle , defaultGroupStyle . QuickQanava provide a ready to use visual Qan.StyleListView component for visualizing, editing styles and dragging them visually on existing graph content.","title":"Defining Styles"},{"location":"styles.html#node-style","text":"Property Description Default Sample backRadius Background rectangle border (corner) radius 4.0 backOpacity Background item opacity 0.85 (85% opaque) 1.0 opacity and 0.30 opacity fillType Background fill ( NodeStyle.FillGradient or NodeStyle.FillSolid ) FillSolid fillType=Gradient with baseColor 'violet' and backColor 'blue' backColor Background color white baseColor Background color used as base (ie top-left) color in gradient fill white baseColor 'violet' and backColor 'blue' borderColor Node border line color black borderWidth Node border line width 1.0 effectType Node effect, either EffectNone , EffectShadow (drop shadow) or EffectGlow Qan.NodeStyle.EffectShadow effectType=EffectShadow and EffectGlow effectEnabled Set to false to disable effect (much more efficient than setting effectType to EffectNone true effectColor Effect color (ie drop shadow or glow effect color) darkgrey 'violet' drop shadow effectRadius Effect radius 8.0 4.0 and 20.0 drop shadow radius effectOffset Effect offset (used only for NodeStyle.EffectShadow ) 4.0 4.0 and 15.0 drop shadow offset","title":"Node Style"},{"location":"styles.html#material-styling","text":"There is easy to use properties shortcuts in Qan.GraphView and Qan.Graph to bind UI elements colors to a Qt Quick Controls 2 theme. The following sample show the minimal necessary binding to support Light and Dark mode when using the Qt Quick Material style: import QtQuick . Controls . Material 2.1 import QuickQanava 2.0 as Qan import \"qrc:/QuickQanava\" as Qan Qan . GraphView { resizeHandlerColor : Material . accent gridThickColor : Material . theme === Material . Dark ? \"#4e4e4e\" : \"#c1c1c1\" topology : Qan . Graph { // ... selectionColor : Material . accent connectorColor : Material . accent connectorEdgeColor : Material . accent // ... } // Qan.Graph // ... } // Qan.GraphView","title":"Material Styling"},{"location":"utilities.html","text":"QuickQanava Utilities \u00b6 BottomRightResizer: \u00b6 Qan.BottomRightResizer add a \"resize handler\" ont the bottom right of a target QML Item. Bottom right resizer component is automatically initialized in the QuickQanava::initialize method, it has no dependencies on QuickQanava and could be used in an isolated project just by copying its source code: fqlBotomRightRizer.h and fqlBotomRightRizer.cpp with a call to qmlRegisterType < fql :: BottomRightResizer > ( \"YourModule\" , 1 , 0 , \"BottomRightResizer\" ); // From c++: qmlRegisterType < fql :: BottomRightResizer > ( \"YourModule\" , 1 , 0 , \"BottomRightResizer\" ); // From QML: import YourModule 1.0 as Fql Item { id : targetItem Fql . BottomRightResizer { target : targetItem } } Resizer not necessarilly has to be in target (host) sibling, Fql . BottomRightResizer could be defined outside of target item hierarchy, for example to avoid corrupting the target childrenRect property. It is however more efficient to use the resizer as a target child (most common case). Navigable: \u00b6 qan::Navigable","title":"Utilities"},{"location":"utilities.html#quickqanava-utilities","text":"","title":"QuickQanava Utilities"},{"location":"utilities.html#bottomrightresizer","text":"Qan.BottomRightResizer add a \"resize handler\" ont the bottom right of a target QML Item. Bottom right resizer component is automatically initialized in the QuickQanava::initialize method, it has no dependencies on QuickQanava and could be used in an isolated project just by copying its source code: fqlBotomRightRizer.h and fqlBotomRightRizer.cpp with a call to qmlRegisterType < fql :: BottomRightResizer > ( \"YourModule\" , 1 , 0 , \"BottomRightResizer\" ); // From c++: qmlRegisterType < fql :: BottomRightResizer > ( \"YourModule\" , 1 , 0 , \"BottomRightResizer\" ); // From QML: import YourModule 1.0 as Fql Item { id : targetItem Fql . BottomRightResizer { target : targetItem } } Resizer not necessarilly has to be in target (host) sibling, Fql . BottomRightResizer could be defined outside of target item hierarchy, for example to avoid corrupting the target childrenRect property. It is however more efficient to use the resizer as a target child (most common case).","title":"BottomRightResizer:"},{"location":"utilities.html#navigable","text":"qan::Navigable","title":"Navigable:"}]}